Index: mythtv/libs/libmythtv/nuppeldecoder.cpp
===================================================================
--- mythtv/libs/libmythtv/nuppeldecoder.cpp	(revision 21594)
+++ mythtv/libs/libmythtv/nuppeldecoder.cpp	(working copy)
@@ -495,6 +495,7 @@
 #endif
         GetNVP()->SetAudioParams(extradata.audio_bits_per_sample,
                                  extradata.audio_channels, 
+                                 CODEC_ID_NONE,
                                  extradata.audio_sample_rate,
                                  false /* AC3/DTS pass through */);
         GetNVP()->ReinitAudio();
Index: mythtv/libs/libmythtv/NuppelVideoPlayer.cpp
===================================================================
--- mythtv/libs/libmythtv/NuppelVideoPlayer.cpp	(revision 21594)
+++ mythtv/libs/libmythtv/NuppelVideoPlayer.cpp	(working copy)
@@ -219,9 +219,9 @@
       audioOutput(NULL),
       audio_main_device(QString::null),
       audio_passthru_device(QString::null),
-      audio_channels(2),            audio_bits(-1),
-      audio_samplerate(44100),      audio_stretchfactor(1.0f),
-      audio_codec(NULL),            audio_lock(QMutex::Recursive),
+      audio_channels(2),            audio_codec(0),
+      audio_bits(-1),               audio_samplerate(44100),
+      audio_stretchfactor(1.0f),    audio_lock(QMutex::Recursive),
       // Picture-in-Picture stuff
       pip_active(false),            pip_visible(true),
       // Preview window support
@@ -922,7 +922,7 @@
         audioOutput = AudioOutput::OpenAudio(audio_main_device,
                                              audio_passthru_device,
                                              audio_bits, audio_channels,
-                                             audio_samplerate,
+                                             audio_codec, audio_samplerate,
                                              AUDIOOUTPUT_VIDEO,
                                              setVolume, audio_passthru);
         if (!audioOutput)
@@ -950,10 +950,11 @@
 
     if (audioOutput)
     {
-        const AudioSettings settings(
-            audio_bits, audio_channels, audio_samplerate,
-            audio_passthru, audio_codec);
+        const AudioSettings settings(audio_bits, audio_channels, audio_codec,
+                                     audio_samplerate, audio_passthru);
         audioOutput->Reconfigure(settings);
+        if (audio_passthru)
+            audio_channels = 2;
         errMsg = audioOutput->GetError();
         if (!errMsg.isEmpty())
             audioOutput->SetStretchFactor(audio_stretchfactor);
@@ -3903,20 +3904,16 @@
     return !IsErrored();
 }
 
-void NuppelVideoPlayer::SetAudioParams(int bps, int channels,
+void NuppelVideoPlayer::SetAudioParams(int bps, int channels, int codec,
                                        int samplerate, bool passthru)
 {
     audio_bits = bps;
     audio_channels = channels;
+    audio_codec = codec;
     audio_samplerate = samplerate;
     audio_passthru = passthru;
 }
 
-void NuppelVideoPlayer::SetAudioCodec(void *ac)
-{
-    audio_codec = ac;
-}
-
 void NuppelVideoPlayer::SetEffDsp(int dsprate)
 {
     if (audioOutput)
@@ -5340,6 +5337,13 @@
     }
 }
 
+bool NuppelVideoPlayer::ToggleUpmix()
+{
+    if (audioOutput)
+        return audioOutput->ToggleUpmix();
+    return false;
+}
+
 void NuppelVideoPlayer::Zoom(ZoomDirection direction)
 {
     if (videoOutput)
Index: mythtv/libs/libmythtv/avformatdecoder.cpp
===================================================================
--- mythtv/libs/libmythtv/avformatdecoder.cpp	(revision 21594)
+++ mythtv/libs/libmythtv/avformatdecoder.cpp	(working copy)
@@ -462,7 +462,7 @@
       audioSamples(NULL),
       allow_ac3_passthru(false),    allow_dts_passthru(false),
       disable_passthru(false),      max_channels(2),
-      dummy_frame(NULL),
+      last_ac3_channels(0),	    dummy_frame(NULL),
       // DVD
       lastdvdtitle(-1),
       decodeStillFrame(false),
@@ -2024,7 +2024,7 @@
     // waiting on audio.
     if (GetNVP()->HasAudioIn() && tracks[kTrackTypeAudio].empty())
     {
-        GetNVP()->SetAudioParams(-1, -1, -1, false /* AC3/DTS pass-through */);
+        GetNVP()->SetAudioParams(-1, -1, CODEC_ID_NONE, -1, false /* AC3/DTS pass-through */);
         GetNVP()->ReinitAudio();
         if (ringBuffer && ringBuffer->isDVD())
             audioIn = AudioInfo();
@@ -3059,15 +3059,9 @@
     {
         int idx = atracks[i].av_stream_index;
         AVCodecContext *codec_ctx = ic->streams[idx]->codec;
-        bool do_ac3_passthru = (allow_ac3_passthru && !transcoding &&
-                                !disable_passthru &&
-                                (codec_ctx->codec_id == CODEC_ID_AC3));
-        bool do_dts_passthru = (allow_dts_passthru && !transcoding &&
-                                !disable_passthru &&
-                                (codec_ctx->codec_id == CODEC_ID_DTS));
         AudioInfo item(codec_ctx->codec_id,
                        codec_ctx->sample_rate, codec_ctx->channels,
-                       do_ac3_passthru || do_dts_passthru);
+                       DoPassThrough(codec_ctx));
         VERBOSE(VB_AUDIO, LOC + " * " + item.toString());
     }
 #endif
@@ -3201,6 +3195,7 @@
 bool AvFormatDecoder::GetFrame(int onlyvideo)
 {
     AVPacket *pkt = NULL;
+    AC3HeaderInfo hdr;
     int len;
     unsigned char *ptr;
     int data_size = 0;
@@ -3631,14 +3626,6 @@
                         reselectAudioTrack = true;
                     }
 
-                    bool do_ac3_passthru =
-                        (allow_ac3_passthru && !transcoding &&
-                         (curstream->codec->codec_id == CODEC_ID_AC3));
-                    bool do_dts_passthru =
-                        (allow_dts_passthru && !transcoding &&
-                         (curstream->codec->codec_id == CODEC_ID_DTS));
-                    bool using_passthru = do_ac3_passthru || do_dts_passthru;
-
                     // detect channels on streams that need
                     // to be decoded before we can know this
                     bool already_decoded = false;
@@ -3649,7 +3636,7 @@
                                 QString("Setting channels to %1")
                                 .arg(audioOut.channels));
 
-                        if (using_passthru)
+                        if (DoPassThrough(curstream->codec))
                         {
                             // for passthru let it select the max number
                             // of channels
@@ -3671,6 +3658,20 @@
                         reselectAudioTrack |= curstream->codec->channels;
                     }
 
+                    if (curstream->codec->codec_id == CODEC_ID_AC3)
+                    {
+                        GetBitContext gbc;
+                        init_get_bits(&gbc, ptr, len * 8);
+                        if (!ff_ac3_parse_header(&gbc, &hdr)) 
+                        {
+                            if (hdr.channels != last_ac3_channels) 
+                            {
+                                last_ac3_channels = curstream->codec->channels = hdr.channels;
+                                SetupAudioStream();
+                            }
+                        }
+                    }
+
                     if (reselectAudioTrack)
                     {
                         QMutexLocker locker(&avcodeclock);
@@ -4196,6 +4197,24 @@
     }
 }
 
+bool AvFormatDecoder::DoPassThrough(const AVCodecContext *ctx)
+{
+    bool passthru = false; 
+
+    if (ctx->codec_id == CODEC_ID_AC3)
+        passthru = allow_ac3_passthru && 
+                   ctx->channels >= (int)max_channels;
+    else if (ctx->codec_id == CODEC_ID_DTS)
+        passthru = allow_dts_passthru;
+
+    passthru &= !transcoding && !disable_passthru;
+    // Don't know any cards that support spdif clocked at < 44100
+    // Some US cable transmissions have 2ch 32k AC-3 streams
+    passthru &= ctx->sample_rate >= 44100;
+
+    return passthru;
+}
+
 /** \fn AvFormatDecoder::SetupAudioStream(void)
  *  \brief Reinitializes audio if it needs to be reinitialized.
  *
@@ -4209,7 +4228,6 @@
     AVStream *curstream = NULL;
     AVCodecContext *codec_ctx = NULL;
     AudioInfo old_in  = audioIn;
-    AudioInfo old_out = audioOut;
     bool using_passthru = false;
 
     if ((currentTrack[kTrackTypeAudio] >= 0) &&
@@ -4223,14 +4241,9 @@
         codec_ctx = curstream->codec;
         if (codec_ctx)
         {
-            bool do_ac3_passthru = (allow_ac3_passthru && !transcoding &&
-                                    (codec_ctx->codec_id == CODEC_ID_AC3));
-            bool do_dts_passthru = (allow_dts_passthru && !transcoding &&
-                                    (codec_ctx->codec_id == CODEC_ID_DTS));
-            using_passthru = do_ac3_passthru || do_dts_passthru;
-            info = AudioInfo(codec_ctx->codec_id,
-                             codec_ctx->sample_rate, codec_ctx->channels,
-                             using_passthru && !disable_passthru);
+            using_passthru = DoPassThrough(codec_ctx);
+            info = AudioInfo(codec_ctx->codec_id, codec_ctx->sample_rate, 
+                            codec_ctx->channels, using_passthru);
         }
     }
 
@@ -4247,41 +4260,25 @@
             QString("audio track #%1").arg(currentTrack[kTrackTypeAudio]+1));
 
     audioOut = audioIn = info;
-    AudioInfo tmpAudioOut = audioOut;
 
-    // A passthru stream looks like a 48KHz 2ch (@ 16bit) to the sound card
-    if (using_passthru && !disable_passthru)
+    if (!using_passthru && audioOut.channels > (int)max_channels)
     {
-        tmpAudioOut.channels    = 2;
-        tmpAudioOut.sample_rate = 48000;
-        tmpAudioOut.sample_size = 4;
-    }
-
-    if (audioOut.channels > (int) max_channels)
-    {
-        audioOut.channels    = (int) max_channels;
+        audioOut.channels = (int)max_channels;
         audioOut.sample_size = audioOut.channels * 2;
-        codec_ctx->channels  = audioOut.channels;
+        codec_ctx->channels = audioOut.channels;
     }
 
-    if (!using_passthru)
-        tmpAudioOut = audioOut;
-
     VERBOSE(VB_AUDIO, LOC + "Audio format changed " +
-            QString("%1%2\n\t\t\tfrom %3 ; %4\n\t\t\tto   %5 ; %6")
-            .arg((using_passthru) ? "digital passthrough " : "")
-            .arg((using_passthru) ? tmpAudioOut.toString() : QString(""))
-            .arg(old_in.toString()).arg(old_out.toString())
-            .arg(audioIn.toString()).arg(audioOut.toString()));
+            QString("\n\t\t\tfrom %1 to %2")
+            .arg(old_in.toString()).arg(audioOut.toString()));
 
-    if (tmpAudioOut.sample_rate > 0)
-        GetNVP()->SetEffDsp(tmpAudioOut.sample_rate * 100);
+    if (audioOut.sample_rate > 0)
+        GetNVP()->SetEffDsp(audioOut.sample_rate * 100);
 
-    GetNVP()->SetAudioParams(tmpAudioOut.bps(), tmpAudioOut.channels,
-                             tmpAudioOut.sample_rate, audioIn.do_passthru);
+    GetNVP()->SetAudioParams(audioOut.bps(), audioOut.channels,
+                             audioOut.codec_id, audioOut.sample_rate,
+                             audioOut.do_passthru);
 
-    // allow the audio stuff to reencode
-    GetNVP()->SetAudioCodec((using_passthru) ? codec_ctx : NULL);
     GetNVP()->ReinitAudio();
 
     return true;
Index: mythtv/libs/libmythtv/tv_play.h
===================================================================
--- mythtv/libs/libmythtv/tv_play.h	(revision 21594)
+++ mythtv/libs/libmythtv/tv_play.h	(working copy)
@@ -429,6 +429,7 @@
     bool TimeStretchHandleAction(PlayerContext*,
                                  const QStringList &actions);
 
+    void ToggleUpmix(PlayerContext*);
     void ChangeAudioSync(PlayerContext*, int dir, bool allowEdit = true);
     bool AudioSyncHandleAction(PlayerContext*, const QStringList &actions);
 
Index: mythtv/libs/libmythtv/NuppelVideoPlayer.h
===================================================================
--- mythtv/libs/libmythtv/NuppelVideoPlayer.h	(revision 21594)
+++ mythtv/libs/libmythtv/NuppelVideoPlayer.h	(working copy)
@@ -126,7 +126,7 @@
     void SetAudioStretchFactor(float factor)  { audio_stretchfactor = factor; }
     void SetAudioOutput(AudioOutput *ao)      { audioOutput = ao; }
     void SetAudioInfo(const QString &main, const QString &passthru, uint rate);
-    void SetAudioParams(int bits, int channels, int samplerate, bool passthru);
+    void SetAudioParams(int bits, int channels, int codec, int samplerate, bool passthru);
     void SetEffDsp(int dsprate);
     uint AdjustVolume(int change);
     bool SetMuted(bool mute);
@@ -180,6 +180,7 @@
     // Toggle Sets
     void ToggleAspectOverride(AspectOverrideMode aspectMode = kAspect_Toggle);
     void ToggleAdjustFill(AdjustFillMode adjustfillMode = kAdjustFill_Toggle);
+    bool ToggleUpmix(void);
 
     // Gets
     QSize   GetVideoBufferSize(void) const    { return video_dim; }
@@ -715,10 +716,10 @@
     QString  audio_main_device;
     QString  audio_passthru_device;
     int      audio_channels;
+    int      audio_codec;
     int      audio_bits;
     int      audio_samplerate;
     float    audio_stretchfactor;
-    void    *audio_codec;
     bool     audio_passthru;
     QMutex   audio_lock;
 
Index: mythtv/libs/libmythtv/tv_play.cpp
===================================================================
--- mythtv/libs/libmythtv/tv_play.cpp	(revision 21594)
+++ mythtv/libs/libmythtv/tv_play.cpp	(working copy)
@@ -491,6 +491,7 @@
     REG_KEY("TV Playback", "VOLUMEDOWN", "Volume down", "[,{,F10,Volume Down");
     REG_KEY("TV Playback", "VOLUMEUP",   "Volume up",   "],},F11,Volume Up");
     REG_KEY("TV Playback", "MUTE",       "Mute",        "|,\\,F9,Volume Mute");
+    REG_KEY("TV Playback", "TOGGLEUPMIX", "Toggle upmixer", "Ctrl+U");
     REG_KEY("TV Playback", "TOGGLEPIPMODE", "Toggle Picture-in-Picture view",
             "V");
     REG_KEY("TV Playback", "TOGGLEPBPMODE", "Toggle Picture-by-Picture view",
@@ -630,7 +631,7 @@
   Teletext     F2,F3,F4,F5,F6,F7,F8
   ITV          F2,F3,F4,F5,F6,F7,F12
 
-  Playback: Ctrl-B,Ctrl-G,Ctrl-Y
+  Playback: Ctrl-B,Ctrl-G,Ctrl-Y,Ctrl-U
 */
 }
 
@@ -4353,6 +4354,8 @@
         DoTogglePictureAttribute(ctx, kAdjustingPicture_Playback);
     else if (has_action("TOGGLESTRETCH", actions))
         ToggleTimeStretch(ctx);
+    else if (has_action("TOGGLEUPMIX", actions))
+        ToggleUpmix(ctx);
     else if (has_action("TOGGLESLEEP", actions))
         ToggleSleepTimer(ctx);
     else if (has_action("TOGGLERECORD", actions) && islivetv)
@@ -8039,6 +8042,20 @@
     SetSpeedChangeTimer(0, __LINE__);
 }
 
+void TV::ToggleUpmix(PlayerContext *ctx)
+{
+    if (!ctx->nvp || !ctx->nvp->HasAudioOut())
+        return;
+    QString text;
+    if (ctx->nvp->ToggleUpmix())
+        text = tr("Upmixer On");
+    else
+        text = tr("Upmixer Off");
+    
+    if (ctx->nvp->GetOSD() && !browsemode)
+        ctx->nvp->GetOSD()->SetSettingsText(text, 5);
+}
+    
 // dir in 10ms jumps
 void TV::ChangeAudioSync(PlayerContext *ctx, int dir, bool allowEdit)
 {
@@ -9668,6 +9685,8 @@
         SetManualZoom(actx, true, tr("Zoom Mode ON"));
     else if (action == "TOGGLESTRETCH")
         ToggleTimeStretch(actx);
+    else if (action == "TOGGLEUPMIX")
+        ToggleUpmix(actx);
     else if (action.left(13) == "ADJUSTSTRETCH")
     {
         bool floatRead;
@@ -10033,6 +10052,8 @@
 
     if (category == "AUDIOSYNC")
         new OSDGenericTree(treeMenu, tr("Adjust Audio Sync"), "TOGGLEAUDIOSYNC");
+    else if (category == "TOGGLEUPMIX")
+        new OSDGenericTree(treeMenu, tr("Toggle Upmixer"), "TOGGLEUPMIX");
     else if (category == "TIMESTRETCH")
         FillMenuTimeStretch(ctx, treeMenu);
     else if (category == "VIDEOSCAN")
Index: mythtv/libs/libmythtv/tvosdmenuentry.cpp
===================================================================
--- mythtv/libs/libmythtv/tvosdmenuentry.cpp	(revision 21594)
+++ mythtv/libs/libmythtv/tvosdmenuentry.cpp	(working copy)
@@ -232,6 +232,8 @@
     curMenuEntries.append(
         new TVOSDMenuEntry("AUDIOSYNC",           1, 1, 1, 1 , "Audio Sync"));
     curMenuEntries.append(
+        new TVOSDMenuEntry("TOGGLEUPMIX",        1, 1, 1, 1, "Toggle Upmixer"));
+    curMenuEntries.append(
         new TVOSDMenuEntry("TIMESTRETCH",        1, 1, 1, 1, "Time Stretch"));
     curMenuEntries.append(
         new TVOSDMenuEntry("VIDEOSCAN",            1, 1, 1, 1, "Video Scan"));
Index: mythtv/libs/libmythtv/avformatdecoder.h
===================================================================
--- mythtv/libs/libmythtv/avformatdecoder.h	(revision 21594)
+++ mythtv/libs/libmythtv/avformatdecoder.h	(working copy)
@@ -188,6 +188,7 @@
 
     void SeekReset(long long, uint skipFrames, bool doFlush, bool discardFrames);
 
+    bool DoPassThrough(const AVCodecContext *ctx);
     bool SetupAudioStream(void);
     void SetupAudioStreamSubIndexes(int streamIndex);
     void RemoveAudioStreams();
@@ -260,6 +261,7 @@
     bool              allow_dts_passthru;
     bool              disable_passthru;
     uint              max_channels;
+    uint              last_ac3_channels;
 
     VideoFrame       *dummy_frame;
 
Index: mythtv/libs/libavcodec/aac.c
===================================================================
--- mythtv/libs/libavcodec/aac.c	(revision 21594)
+++ mythtv/libs/libavcodec/aac.c	(working copy)
@@ -98,7 +98,11 @@
 static VLC vlc_scalefactors;
 static VLC vlc_spectral[11];
 
+#define CHAN_MAP_MAX 6
 
+static int chan_map[CHAN_MAP_MAX] = { 2, 0, 6, 4, 3, 2 }; 
+
+
 static ChannelElement* get_che(AACContext *ac, int type, int elem_id) {
     static const int8_t tags_per_config[16] = { 0, 1, 1, 2, 3, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0 };
     if (ac->tag_che_map[type][elem_id]) {
@@ -167,10 +171,8 @@
     /* Allocate or free elements depending on if they are in the
      * current program configuration.
      *
-     * Set up default 1:1 output mapping.
+     * Set up default SMPTE output mapping.
      *
-     * For a 5.1 stream the output order will be:
-     *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
      */
 
     for(i = 0; i < MAX_ELEM_ID; i++) {
@@ -179,10 +181,26 @@
                 if(!ac->che[type][i] && !(ac->che[type][i] = av_mallocz(sizeof(ChannelElement))))
                     return AVERROR(ENOMEM);
                 if(type != TYPE_CCE) {
-                    ac->output_data[channels++] = ac->che[type][i]->ch[0].ret;
-                    if(type == TYPE_CPE) {
-                        ac->output_data[channels++] = ac->che[type][i]->ch[1].ret;
+                    /* Convert to SMPTE channel order */
+                    int ch = 0;
+                    if (che_pos[type][i] < CHAN_MAP_MAX) {
+                        if (che_pos[type][i] == AAC_CHANNEL_FRONT)
+                            ch == TYPE_SCE ? /* center */ 2 : /* FL */ 0;
+                        else 
+                            ch = chan_map[che_pos[type][i]];
+                        ac->output_data[ch] = ac->che[type][i]->ch[0].ret;
+                        channels++;
+                        if(type == TYPE_CPE) {
+                            ac->output_data[ch + 1] = ac->che[type][i]->ch[1].ret;
+                            channels++;
+                        }
                     }
+                    else {
+                        ac->output_data[channels++] = ac->che[type][i]->ch[0].ret;
+                        if(type == TYPE_CPE) {
+                            ac->output_data[channels++] = ac->che[type][i]->ch[1].ret;
+                        }
+                    }
                 }
             } else
                 av_freep(&ac->che[type][i]);
Index: mythtv/libs/libmyth/audiooutputjack.h
===================================================================
--- mythtv/libs/libmyth/audiooutputjack.h	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputjack.h	(working copy)
@@ -23,6 +23,7 @@
     virtual void WriteAudio(unsigned char *aubuf, int size);
     virtual int  GetSpaceOnSoundcard(void) const;
     virtual int  GetBufferedOnSoundcard(void) const;
+    vector<int> GetSupportedRates(void); 
 
   private:
 
Index: mythtv/libs/libmyth/audiosettings.cpp
===================================================================
--- mythtv/libs/libmyth/audiosettings.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiosettings.cpp	(working copy)
@@ -12,10 +12,10 @@
     passthru_device(QString::null),
     bits(-1),
     channels(-1),
+    codec(0),
     samplerate(-1),
     set_initial_vol(false),
     use_passthru(false),
-    codec(NULL),
     source(AUDIOOUTPUT_UNKNOWN)
 {
 }
@@ -25,10 +25,10 @@
     passthru_device(other.passthru_device),
     bits(other.bits),
     channels(other.channels),
+    codec(other.codec),
     samplerate(other.samplerate),
     set_initial_vol(other.set_initial_vol),
     use_passthru(other.use_passthru),
-    codec(other.codec),
     source(other.source)
 {
 }
@@ -38,19 +38,19 @@
     const QString &audio_passthru_device,
     int audio_bits,
     int audio_channels,
+    int audio_codec,
     int audio_samplerate,
     AudioOutputSource audio_source,
     bool audio_set_initial_vol,
-    bool audio_use_passthru,
-    void *audio_codec) :
+    bool audio_use_passthru) :
     main_device(audio_main_device),
     passthru_device(audio_passthru_device),
     bits(audio_bits),
     channels(audio_channels),
+    codec(audio_codec),
     samplerate(audio_samplerate),
     set_initial_vol(audio_set_initial_vol),
     use_passthru(audio_use_passthru),
-    codec(audio_codec),
     source(audio_source)
 {
 }
@@ -58,17 +58,17 @@
 AudioSettings::AudioSettings(
     int   audio_bits, 
     int   audio_channels, 
+    int   audio_codec,
     int   audio_samplerate,
-    bool  audio_use_passthru,
-    void *audio_codec) :
+    bool  audio_use_passthru) :
     main_device(QString::null),
     passthru_device(QString::null),
     bits(audio_bits),
     channels(audio_channels),
+    codec(audio_codec),
     samplerate(audio_samplerate),
     set_initial_vol(false),
     use_passthru(audio_use_passthru),
-    codec(audio_codec),
     source(AUDIOOUTPUT_UNKNOWN)
 {
 }
Index: mythtv/libs/libmyth/audiooutputbase.h
===================================================================
--- mythtv/libs/libmyth/audiooutputbase.h	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputbase.h	(working copy)
@@ -43,6 +43,7 @@
 
     virtual void SetStretchFactor(float factor);
     virtual float GetStretchFactor(void) const;
+    virtual bool ToggleUpmix(void);
 
     virtual void Reset(void);
 
@@ -85,6 +86,8 @@
     virtual void WriteAudio(unsigned char *aubuf, int size) = 0;
     virtual int  GetSpaceOnSoundcard(void) const = 0;
     virtual int  GetBufferedOnSoundcard(void) const = 0;
+    virtual vector<int> GetSupportedRates(void) 
+        { vector<int> rates; return rates; }
     /// You need to call this from any implementation in the dtor.
     void KillAudio(void);
 
@@ -122,6 +125,7 @@
 
     // Basic details about the audio stream
     int audio_channels;
+    int audio_codec;
     int audio_bytes_per_sample;
     int audio_bits;
     int audio_samplerate;
@@ -132,9 +136,10 @@
     QString audio_passthru_device;
 
     bool audio_passthru;
+    bool audio_enc;
+    bool audio_reenc;
 
     float audio_stretchfactor;
-    AVCodecContext *audio_codec;
     AudioOutputSource source;
 
     bool killaudio;
@@ -144,6 +149,8 @@
     bool buffer_output_data_for_use; //  used by AudioOutputNULL
 
     int configured_audio_channels;
+    int orig_config_channels;
+    int src_quality;
 
  private:
     // resampler
@@ -156,9 +163,12 @@
     FreeSurround              *upmixer;
 
     int source_audio_channels;
+    int source_audio_samplerate;
     int source_audio_bytes_per_sample;
     bool needs_upmix;
     int surround_mode;
+    bool allow_ac3_passthru;
+    float old_audio_stretchfactor;
 
     bool blocking; // do AddSamples calls block?
 
Index: mythtv/libs/libmyth/audiooutputalsa.cpp
===================================================================
--- mythtv/libs/libmyth/audiooutputalsa.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputalsa.cpp	(working copy)
@@ -32,13 +32,125 @@
 AudioOutputALSA::~AudioOutputALSA()
 {
     KillAudio();
+    SetIECStatus(true);
 }
 
+void AudioOutputALSA::SetIECStatus(bool audio)
+{
+    snd_ctl_t *ctl;
+    const char *spdif_str = SND_CTL_NAME_IEC958("", PLAYBACK, DEFAULT);
+    int spdif_index = -1;
+    snd_ctl_elem_list_t *clist;
+    snd_ctl_elem_id_t *cid;
+    snd_ctl_elem_value_t *cval;
+    snd_aes_iec958_t iec958;
+    int cidx, controls;
+
+    VERBOSE(VB_AUDIO, QString("Setting IEC958 status: %1")
+                      .arg(audio ? "audio" : "non-audio"));
+
+    int err;
+    if ((err = snd_ctl_open(&ctl, "default", 0)) < 0)
+    {
+        Error(QString("AudioOutputALSA::SetIECStatus: snd_ctl_open(default): %1")
+              .arg(snd_strerror(err)));
+        return;
+    }
+    snd_ctl_elem_list_alloca(&clist);
+    snd_ctl_elem_list(ctl, clist);
+    snd_ctl_elem_list_alloc_space(clist, snd_ctl_elem_list_get_count(clist));
+    snd_ctl_elem_list(ctl, clist);
+    controls = snd_ctl_elem_list_get_used(clist);
+    for (cidx = 0; cidx < controls; cidx++)
+    {
+        if (!strcmp(snd_ctl_elem_list_get_name(clist, cidx), spdif_str))
+            if (spdif_index < 0 ||
+                snd_ctl_elem_list_get_index(clist, cidx) == (uint)spdif_index)
+                    break;
+    }
+
+    if (cidx >= controls)
+        return;
+
+    snd_ctl_elem_id_alloca(&cid);
+    snd_ctl_elem_list_get_id(clist, cidx, cid);
+    snd_ctl_elem_value_alloca(&cval);
+    snd_ctl_elem_value_set_id(cval, cid);
+    snd_ctl_elem_read(ctl,cval);
+    snd_ctl_elem_value_get_iec958(cval, &iec958);
+
+    if (!audio) 
+        iec958.status[0] |= IEC958_AES0_NONAUDIO;
+    else
+        iec958.status[0] &= ~IEC958_AES0_NONAUDIO;
+
+    snd_ctl_elem_value_set_iec958(cval, &iec958);
+    snd_ctl_elem_write(ctl, cval);
+}
+
+vector<int> AudioOutputALSA::GetSupportedRates()
+{
+    snd_pcm_hw_params_t *params;
+    int err;
+    const int srates[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
+    vector<int> rates(srates, srates + sizeof(srates) / sizeof(int) );
+    QString real_device;
+    
+    if (audio_passthru || audio_enc)
+        real_device = audio_passthru_device;
+    else 
+        real_device = audio_main_device;
+
+    if((err = snd_pcm_open(&pcm_handle, real_device.toAscii(),
+                           SND_PCM_STREAM_PLAYBACK, 
+                           SND_PCM_NONBLOCK|SND_PCM_NO_AUTO_RESAMPLE)) < 0)
+    { 
+        Error(QString("snd_pcm_open(%1): %2")
+              .arg(real_device).arg(snd_strerror(err)));
+
+        if (pcm_handle)
+        {
+            snd_pcm_close(pcm_handle);
+            pcm_handle = NULL;
+        }
+        rates.clear();
+        return rates;
+    }
+    
+    snd_pcm_hw_params_alloca(&params);
+
+    if ((err = snd_pcm_hw_params_any(pcm_handle, params)) < 0)
+    {
+        Error(QString("Broken configuration for playback; no configurations"
+              " available: %1").arg(snd_strerror(err)));
+        snd_pcm_close(pcm_handle);
+        pcm_handle = NULL;
+        rates.clear();
+        return rates;
+    }
+    
+    vector<int>::iterator it = rates.begin();
+
+    while (it != rates.end())
+    {
+        if(snd_pcm_hw_params_test_rate(pcm_handle, params, *it, 0) < 0)
+            it = rates.erase(it);
+        else
+            it++;
+    }
+    
+    snd_pcm_close(pcm_handle);
+    pcm_handle = NULL;
+
+    return rates;
+}
+
 bool AudioOutputALSA::OpenDevice()
 {
     snd_pcm_format_t format;
     unsigned int buffer_time, period_time;
     int err;
+    QString real_device;
 
     if (pcm_handle != NULL)
         CloseDevice();
@@ -46,8 +158,16 @@
     pcm_handle = NULL;
     numbadioctls = 0;
 
-    QString real_device = (audio_passthru) ?
-        audio_passthru_device : audio_main_device;
+    if (audio_passthru || audio_enc)
+    {
+        real_device = audio_passthru_device;
+        SetIECStatus(false);
+    }
+    else 
+    {
+        real_device = audio_main_device;
+        SetIECStatus(true);
+    }
 
     VERBOSE(VB_GENERAL, QString("Opening ALSA audio device '%1'.")
             .arg(real_device));
@@ -146,7 +266,29 @@
     }
 }
 
+void AudioOutputALSA::ReorderSmpteToAlsa6ch(unsigned char *buf, int size) 
+{
+    if (audio_bits == 8)
+        _ReorderSmpteToAlsa6ch(buf, size);
+    else if (audio_bits == 16)
+        _ReorderSmpteToAlsa6ch((short *)buf, size / sizeof(short));
+}
 
+template <class AudioDataType>
+void AudioOutputALSA::_ReorderSmpteToAlsa6ch(AudioDataType *buf, int size) 
+{
+    AudioDataType tmpC, tmpLFE;
+
+    for (int i = 0; i < size; i+= 6) {
+        tmpC = buf[i+2];
+        tmpLFE = buf[i+3];
+        buf[i+2] = buf[i+4];
+        buf[i+3] = buf[i+5];
+        buf[i+4] = tmpC;
+        buf[i+5] = tmpLFE;
+    }
+
+}
 void AudioOutputALSA::WriteAudio(unsigned char *aubuf, int size)
 {
     unsigned char *tmpbuf;
@@ -158,6 +300,10 @@
         VERBOSE(VB_IMPORTANT, QString("WriteAudio() called with pcm_handle == NULL!"));
         return;
     }
+
+    if (!(audio_passthru || audio_enc) && audio_channels == 6)
+        ReorderSmpteToAlsa6ch(aubuf, size);
+
     
     tmpbuf = aubuf;
 
Index: mythtv/libs/libmyth/audiooutputjack.cpp
===================================================================
--- mythtv/libs/libmyth/audiooutputjack.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputjack.cpp	(working copy)
@@ -30,6 +30,44 @@
     Reconfigure(settings);
 }
 
+vector<int> AudioOutputJACK::GetSupportedRates()
+{
+    const int srates[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
+    vector<int> rates(srates, srates + sizeof(srates) / sizeof(int) );
+    unsigned long jack_port_flags = 0;
+    unsigned int jack_port_name_count = 1;
+    const char *jack_port_name = audio_main_device.toAscii();
+    int err = -1;
+    audioid = -1;
+    vector<int>::iterator it = rates.begin();
+
+    while (it != rates.end())
+    {
+        unsigned long lrate = (unsigned long) *it;
+        err = JACK_OpenEx(&audioid, 16, &lrate,
+                          2, 2, &jack_port_name, jack_port_name_count,
+                          jack_port_flags);
+
+        if (err == ERR_OPENING_JACK)
+        {
+            Error(QString("Error connecting to jackd: %1. Is it running?")
+                  .arg(audio_main_device));
+            rates.clear();
+            return rates;
+        }
+        else
+            if (err == ERR_RATE_MISMATCH)
+                it = rates.erase(it);
+            else
+                it++;
+
+        JACK_Close(audioid);
+        audioid = -1;
+    }
+    return rates;
+}
+
+
 AudioOutputJACK::~AudioOutputJACK()
 {
     // Close down all audio stuff
Index: mythtv/libs/libmyth/audiooutputoss.h
===================================================================
--- mythtv/libs/libmyth/audiooutputoss.h	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputoss.h	(working copy)
@@ -23,6 +23,7 @@
     virtual void WriteAudio(unsigned char *aubuf, int size);
     virtual int  GetSpaceOnSoundcard(void) const;
     virtual int  GetBufferedOnSoundcard(void) const;
+    vector<int> GetSupportedRates(void);
 
   private:
     void VolumeInit(void);
Index: mythtv/libs/libmyth/audiooutputbase.cpp
===================================================================
--- mythtv/libs/libmyth/audiooutputbase.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputbase.cpp	(working copy)
@@ -21,16 +21,16 @@
 AudioOutputBase::AudioOutputBase(const AudioSettings &settings) :
     // protected
     effdsp(0),                  effdspstretched(0),
-    audio_channels(-1),         audio_bytes_per_sample(0),
-    audio_bits(-1),             audio_samplerate(-1),
-    audio_buffer_unused(0),
+    audio_channels(-1),         audio_codec(CODEC_ID_NONE),
+    audio_bytes_per_sample(0),  audio_bits(-1),
+    audio_samplerate(-1),       audio_buffer_unused(0),
     fragment_size(0),           soundcard_buffer_size(0),
 
     audio_main_device(settings.GetMainDevice()),
     audio_passthru_device(settings.GetPassthruDevice()),
-    audio_passthru(false),      audio_stretchfactor(1.0f),
+    audio_passthru(false),      audio_enc(false),
+    audio_reenc(false),         audio_stretchfactor(1.0f),
 
-    audio_codec(NULL),
     source(settings.source),    killaudio(false),
 
     pauseaudio(false),          audio_actually_paused(false),
@@ -48,9 +48,11 @@
     encoder(NULL),
     upmixer(NULL),
     source_audio_channels(-1),
+    source_audio_samplerate(0),
     source_audio_bytes_per_sample(0),
     needs_upmix(false),
     surround_mode(FreeSurround::SurroundModePassive),
+    old_audio_stretchfactor(1.0),
 
     blocking(false),
 
@@ -79,6 +81,9 @@
     memset(&audiotime_updated, 0, sizeof(audiotime_updated));
     memset(audiobuffer,        0, sizeof(char)  * kAudioRingBufferSize);
     configured_audio_channels = gContext->GetNumSetting("MaxChannels", 2);
+    orig_config_channels = configured_audio_channels;
+    allow_ac3_passthru = gContext->GetNumSetting("AC3PassThru", false);
+    src_quality = gContext->GetNumSetting("SRCQuality", 3);
 
     // You need to call Reconfigure from your concrete class.
     // Reconfigure(laudio_bits,       laudio_channels,
@@ -124,48 +129,16 @@
             VERBOSE(VB_GENERAL, LOC + QString("Using time stretch %1")
                                         .arg(audio_stretchfactor));
             pSoundStretch = new soundtouch::SoundTouch();
-            if (audio_codec)
-            {
-                if (!encoder)
-                {
-                    VERBOSE(VB_AUDIO, LOC +
-                            QString("Creating Encoder for codec %1 origfs %2")
-                            .arg(audio_codec->codec_id)
-                            .arg(audio_codec->frame_size));
+            pSoundStretch->setSampleRate(audio_samplerate);
+            pSoundStretch->setChannels(upmixer ? 
+                configured_audio_channels : source_audio_channels);
 
-                    encoder = new AudioOutputDigitalEncoder();
-                    if (!encoder->Init(audio_codec->codec_id,
-                                audio_codec->bit_rate,
-                                audio_codec->sample_rate,
-                                audio_codec->channels
-                                ))
-                    {
-                        // eeks
-                        delete encoder;
-                        encoder = NULL;
-                        VERBOSE(VB_AUDIO, LOC +
-                                QString("Failed to Create Encoder"));
-                    }
-                }
-            }
-            if (audio_codec && encoder)
-            {
-                pSoundStretch->setSampleRate(audio_codec->sample_rate);
-                pSoundStretch->setChannels(audio_codec->channels);
-            }
-            else
-            {
-                pSoundStretch->setSampleRate(audio_samplerate);
-                pSoundStretch->setChannels(audio_channels);
-            }
-
             pSoundStretch->setTempo(audio_stretchfactor);
             pSoundStretch->setSetting(SETTING_SEQUENCE_MS, 35);
 
             // dont need these with only tempo change
             //pSoundStretch->setPitch(1.0);
             //pSoundStretch->setRate(1.0);
-
             //pSoundStretch->setSetting(SETTING_USE_QUICKSEEK, true);
             //pSoundStretch->setSetting(SETTING_USE_AA_FILTER, false);
         }
@@ -183,36 +156,44 @@
     return audio_stretchfactor;
 }
 
+bool AudioOutputBase::ToggleUpmix(void)
+{
+    if (orig_config_channels == 2 || source_audio_channels > 2 ||
+        audio_passthru)
+        return false;
+    if (configured_audio_channels == 6)
+        configured_audio_channels = 2;
+    else
+        configured_audio_channels = 6;
+
+    const AudioSettings settings(audio_bits, source_audio_channels,
+                                 audio_codec, source_audio_samplerate,
+                                 audio_passthru);
+    Reconfigure(settings);
+    return (configured_audio_channels == 6);
+}
+
+
 void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
 {
     AudioSettings settings = orig_settings;
 
-    int codec_id = CODEC_ID_NONE;
-    int lcodec_id = CODEC_ID_NONE;
-    int lcchannels = 0;
-    int cchannels = 0;
     int lsource_audio_channels = settings.channels;
     bool lneeds_upmix = false;
+    bool laudio_reenc = false;
 
-    if (settings.codec)
+    // Are we reencoding a (previously) timestretched bitstream?
+    if ((settings.codec == CODEC_ID_AC3 || settings.codec == CODEC_ID_DTS) &&
+        !settings.use_passthru && allow_ac3_passthru)
     {
-        lcodec_id = ((AVCodecContext*)settings.codec)->codec_id;
-        settings.bits = 16;
-        settings.channels = 2;
-        lsource_audio_channels = settings.channels;
-        settings.samplerate = 48000;
-        lcchannels = ((AVCodecContext*)settings.codec)->channels;
+        laudio_reenc = true;
+        VERBOSE(VB_AUDIO, LOC + "Reencoding decoded AC3/DTS to AC3");
     }
 
-    if (audio_codec)
+    // Enough channels? Upmix if not
+    if (settings.channels < configured_audio_channels &&
+        !settings.use_passthru)
     {
-        codec_id = audio_codec->codec_id;
-        cchannels = ((AVCodecContext*)audio_codec)->channels;
-    }
-
-    if ((configured_audio_channels == 6) &&
-        !(settings.codec || audio_codec))
-    {
         settings.channels = configured_audio_channels;
         lneeds_upmix = true;
         VERBOSE(VB_AUDIO,LOC + "Needs upmix");
@@ -224,7 +205,7 @@
         settings.samplerate == audio_samplerate && !need_resampler &&
         settings.use_passthru == audio_passthru &&
         lneeds_upmix == needs_upmix &&
-        lcodec_id == codec_id && lcchannels == cchannels);
+        laudio_reenc == audio_reenc);
     bool upmix_deps =
         (lsource_audio_channels == source_audio_channels);
     if (general_deps && upmix_deps)
@@ -251,12 +232,12 @@
     waud = raud = 0;
     audio_actually_paused = false;
 
-    bool redo_stretch = (pSoundStretch && audio_channels != settings.channels);
     audio_channels = settings.channels;
     source_audio_channels = lsource_audio_channels;
     audio_bits = settings.bits;
-    audio_samplerate = settings.samplerate;
-    audio_codec = (AVCodecContext*)settings.codec;
+    source_audio_samplerate = audio_samplerate = settings.samplerate;
+    audio_reenc = laudio_reenc;
+    audio_codec = settings.codec;
     audio_passthru = settings.use_passthru;
     needs_upmix = lneeds_upmix;
 
@@ -265,8 +246,9 @@
         Error("AudioOutput only supports 8 or 16bit audio.");
         return;
     }
-    audio_bytes_per_sample = audio_channels * audio_bits / 8;
-    source_audio_bytes_per_sample = source_audio_channels * audio_bits / 8;
+    
+    VERBOSE(VB_AUDIO, LOC + QString("Original audio codec was %1")
+                            .arg(codec_id_string((CodecID)audio_codec)));
 
     need_resampler = false;
     killaudio = false;
@@ -275,7 +257,70 @@
     internal_vol = gContext->GetNumSetting("MythControlsVolume", 0);
 
     numlowbuffer = 0;
+    
+    // Find out what sample rates we can output (if output layer supports it)
+    vector<int> rates = GetSupportedRates();
+    vector<int>::iterator it;
+    bool resample = true;
 
+    for (it = rates.begin(); it < rates.end(); it++)
+    {
+        VERBOSE(VB_AUDIO, LOC + QString("Sample rate %1 is supported")
+                                .arg(*it));
+        if (*it == audio_samplerate)
+            resample = false;
+    }
+
+    // Assume 48k if we can't get supported rates
+    if (rates.empty())
+        rates.push_back(48000);
+
+    if (resample)
+    {
+        int error;
+        audio_samplerate = *(rates.end());
+        VERBOSE(VB_GENERAL, LOC + QString("Using resampler. From: %1 to %2")
+            .arg(settings.samplerate).arg(audio_samplerate));
+        src_ctx = src_new(3-src_quality, source_audio_channels, &error);
+        if (error)
+        {
+            Error(QString("Error creating resampler, the error was: %1")
+                  .arg(src_strerror(error)) );
+	    src_ctx = NULL;
+            return;
+        }
+        src_data.src_ratio = (double) audio_samplerate / settings.samplerate;
+        src_data.data_in = src_in;
+        src_data.data_out = src_out;
+        src_data.output_frames = 16384*6;
+        need_resampler = true;
+    }
+    
+    // Encode to AC-3 if not passing thru , there's > 2 channels
+    // and a passthru device is defined
+    if (!audio_passthru && allow_ac3_passthru &&
+        (audio_channels > 2 || audio_reenc))
+    {
+        VERBOSE(VB_AUDIO, LOC + "Creating AC-3 Encoder");
+        encoder = new AudioOutputDigitalEncoder();
+        if (!encoder->Init(CODEC_ID_AC3, 448000, audio_samplerate, 
+                           audio_channels))
+        {
+            VERBOSE(VB_AUDIO, LOC + "Can't create AC-3 encoder");
+            delete encoder;
+            encoder = NULL;
+        }
+
+        audio_enc = true;
+    }
+
+    if(audio_passthru || audio_enc)
+        // AC-3 output - soundcard expects a 2ch 48k stream
+	audio_channels = 2;
+
+    audio_bytes_per_sample = audio_channels * audio_bits / 8;
+    source_audio_bytes_per_sample = source_audio_channels * audio_bits / 8;
+
     VERBOSE(VB_GENERAL, QString("Opening audio device '%1'. ch %2(%3) sr %4")
             .arg(audio_main_device).arg(audio_channels)
             .arg(source_audio_channels).arg(audio_samplerate));
@@ -309,27 +354,6 @@
     current_seconds = -1;
     source_bitrate = -1;
 
-    // NOTE: this won't do anything as above samplerate vars are set equal
-    // Check if we need the resampler
-    if (audio_samplerate != settings.samplerate)
-    {
-        int error;
-        VERBOSE(VB_GENERAL, LOC + QString("Using resampler. From: %1 to %2")
-                               .arg(settings.samplerate).arg(audio_samplerate));
-        src_ctx = src_new (SRC_SINC_BEST_QUALITY, audio_channels, &error);
-        if (error)
-        {
-            Error(QString("Error creating resampler, the error was: %1")
-                  .arg(src_strerror(error)) );
-            return;
-        }
-        src_data.src_ratio = (double) audio_samplerate / settings.samplerate;
-        src_data.data_in = src_in;
-        src_data.data_out = src_out;
-        src_data.output_frames = 16384*6;
-        need_resampler = true;
-    }
-
     if (needs_upmix)
     {
         VERBOSE(VB_AUDIO, LOC + QString("create upmixer"));
@@ -344,63 +368,15 @@
             (FreeSurround::SurroundMode)surround_mode);
 
         VERBOSE(VB_AUDIO, LOC +
-                QString("create upmixer done with surround mode %1")
+                QString("Create upmixer done with surround mode %1")
                 .arg(surround_mode));
     }
 
     VERBOSE(VB_AUDIO, LOC + QString("Audio Stretch Factor: %1")
             .arg(audio_stretchfactor));
-    VERBOSE(VB_AUDIO, QString("Audio Codec Used: %1")
-            .arg((audio_codec) ?
-                 codec_id_string(audio_codec->codec_id) : "not set"));
 
-    if (redo_stretch)
-    {
-        delete pSoundStretch;
-        pSoundStretch = NULL;
-        SetStretchFactorLocked(audio_stretchfactor);
-    }
-    else
-    {
-        SetStretchFactorLocked(audio_stretchfactor);
-        if (pSoundStretch)
-        {
-            // if its passthru then we need to reencode
-            if (audio_codec)
-            {
-                if (!encoder)
-                {
-                    VERBOSE(VB_AUDIO, LOC +
-                            QString("Creating Encoder for codec %1")
-                            .arg(audio_codec->codec_id));
-
-                    encoder = new AudioOutputDigitalEncoder();
-                    if (!encoder->Init(audio_codec->codec_id,
-                                audio_codec->bit_rate,
-                                audio_codec->sample_rate,
-                                audio_codec->channels
-                                ))
-                    {
-                        // eeks
-                        delete encoder;
-                        encoder = NULL;
-                        VERBOSE(VB_AUDIO, LOC + "Failed to Create Encoder");
-                    }
-                }
-            }
-            if (audio_codec && encoder)
-            {
-                pSoundStretch->setSampleRate(audio_codec->sample_rate);
-                pSoundStretch->setChannels(audio_codec->channels);
-            }
-            else
-            {
-                pSoundStretch->setSampleRate(audio_samplerate);
-                pSoundStretch->setChannels(audio_channels);
-            }
-        }
-    }
-
+    SetStretchFactorLocked(old_audio_stretchfactor);
+    
     // Setup visualisations, zero the visualisations buffers
     prepareVisuals();
 
@@ -436,10 +412,15 @@
     VERBOSE(VB_AUDIO, LOC + "Killing AudioOutputDSP");
     killaudio = true;
     StopOutputThread();
+    QMutexLocker lock1(&audio_buflock);
 
     // Close resampler?
     if (src_ctx)
+    {
         src_delete(src_ctx);
+        src_ctx = NULL;
+    }
+
     need_resampler = false;
 
     // close sound stretcher
@@ -447,6 +428,8 @@
     {
         delete pSoundStretch;
         pSoundStretch = NULL;
+        old_audio_stretchfactor = audio_stretchfactor;
+        audio_stretchfactor = 1.0;
     }
 
     if (encoder)
@@ -461,6 +444,7 @@
         upmixer = NULL;
     }
     needs_upmix = false;
+    audio_enc = false;
 
     CloseDevice();
 
@@ -611,21 +595,15 @@
 
     // include algorithmic latencies
     if (pSoundStretch)
-    {
-        // add the effect of any unused but processed samples,
-        // AC3 reencode does this
-        totalbuffer += (int)(pSoundStretch->numSamples() *
-                             audio_bytes_per_sample);
-        // add the effect of unprocessed samples in time stretch algo
         totalbuffer += (int)((pSoundStretch->numUnprocessedSamples() *
                               audio_bytes_per_sample) / audio_stretchfactor);
-    }
 
     if (upmixer && needs_upmix)
-    {
         totalbuffer += upmixer->sampleLatency() * audio_bytes_per_sample;
-    }
 
+    if (encoder) 
+         totalbuffer += encoder->Buffered();
+
     audiotime = audbuf_timecode - (int)(totalbuffer * 100000.0 /
                                    (audio_bytes_per_sample * effdspstretched));
 
@@ -681,6 +659,8 @@
         return false; // would overflow
     }
 
+    QMutexLocker lock1(&audio_buflock);
+
     // resample input if necessary
     if (need_resampler && src_ctx)
     {
@@ -725,6 +705,10 @@
     int abps = (encoder) ?
         encoder->audio_bytes_per_sample : audio_bytes_per_sample;
     int len = samples * abps;
+    
+    // Give original samples to mythmusic visualisation
+    dispatchVisual((unsigned char *)buffer, len, timecode,
+                   source_audio_channels, audio_bits);
 
     // Check we have enough space to write the data
     if (need_resampler && src_ctx)
@@ -749,6 +733,8 @@
         return false; // would overflow
     }
 
+    QMutexLocker lock1(&audio_buflock);
+
     // resample input if necessary
     if (need_resampler && src_ctx)
     {
@@ -809,9 +795,12 @@
             {
                 int error = src_reset(src_ctx);
                 if (error)
+                {
                     VERBOSE(VB_IMPORTANT, LOC_ERR + QString(
                             "Error occured while resetting resampler: %1")
                             .arg(src_strerror(error)));
+                    src_ctx = NULL;
+                }
             }
         }
     }
@@ -821,8 +810,6 @@
 void AudioOutputBase::_AddSamples(void *buffer, bool interleaved, int samples,
                                   long long timecode)
 {
-    audio_buflock.lock();
-
     int len; // = samples * audio_bytes_per_sample;
     int audio_bytes = audio_bits / 8;
     int org_waud = waud;
@@ -839,17 +826,17 @@
             .arg(samples * abps)
             .arg(kAudioRingBufferSize-afree).arg(afree).arg(timecode)
             .arg(needs_upmix));
-
+    
+    len = WaitForFreeSpace(samples);
+        
     if (upmixer && needs_upmix)
     {
         int out_samples = 0;
+        org_waud = waud;
         int step = (interleaved)?source_audio_channels:1;
-        len = WaitForFreeSpace(samples);    // test
+	
         for (int itemp = 0; itemp < samples; )
         {
-            // just in case it does a processing cycle, release the lock
-            // to allow the output loop to do output
-            audio_buflock.unlock();
             if (audio_bytes == 2)
             {
                 itemp += upmixer->putSamples(
@@ -866,7 +853,6 @@
                     source_audio_channels,
                     (interleaved) ? 0 : samples);
             }
-            audio_buflock.lock();
 
             int copy_samples = upmixer->numSamples();
             if (copy_samples)
@@ -900,8 +886,6 @@
     }
     else
     {
-        len = WaitForFreeSpace(samples);
-
         if (interleaved)
         {
             char *mybuf = (char*)buffer;
@@ -936,138 +920,99 @@
         }
     }
 
-    if (samples > 0)
+    if (samples <= 0)
+        return;
+        
+    if (pSoundStretch)
     {
-        if (pSoundStretch)
+        // does not change the timecode, only the number of samples
+        // back to orig pos
+        org_waud = waud;
+        int bdiff = kAudioRingBufferSize - org_waud;
+        int nSamplesToEnd = bdiff/abps;
+        if (bdiff < len)
         {
+            pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
+                                      (audiobuffer +
+                                       org_waud), nSamplesToEnd);
+            pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)audiobuffer,
+                                      (len - bdiff) / abps);
+        }
+        else
+        {
+            pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
+                                      (audiobuffer + org_waud),
+                                      len / abps);
+        }
 
-            // does not change the timecode, only the number of samples
-            // back to orig pos
-            org_waud = waud;
-            int bdiff = kAudioRingBufferSize - org_waud;
-            int nSamplesToEnd = bdiff/abps;
-            if (bdiff < len)
-            {
-                pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
-                                          (audiobuffer +
-                                           org_waud), nSamplesToEnd);
-                pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)audiobuffer,
-                                          (len - bdiff) / abps);
+        int nSamples = pSoundStretch->numSamples();
+        len = WaitForFreeSpace(nSamples); 
+        
+        while ((nSamples = pSoundStretch->numSamples())) 
+        {
+            if (nSamples > nSamplesToEnd) 
+                nSamples = nSamplesToEnd;
+            
+            nSamples = pSoundStretch->receiveSamples(
+                (soundtouch::SAMPLETYPE*)
+                (audiobuffer + org_waud), nSamples
+            );
+            
+            if (nSamples == nSamplesToEnd) {
+                org_waud = 0;
+                nSamplesToEnd = kAudioRingBufferSize/abps;
             }
-            else
-            {
-                pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
-                                          (audiobuffer + org_waud),
-                                          len / abps);
+            else {
+                org_waud += nSamples * abps;
+                nSamplesToEnd -= nSamples;
             }
-
-            if (encoder)
-            {
-                // pull out a packet's worth and reencode it until we
-                // don't have enough for any more packets
-                soundtouch::SAMPLETYPE *temp_buff =
-                    (soundtouch::SAMPLETYPE*)encoder->GetFrameBuffer();
-                size_t frameSize = encoder->FrameSize()/abps;
-
-                VERBOSE(VB_AUDIO+VB_TIMESTAMP,
-                        QString("_AddSamples Enc sfs=%1 bfs=%2 sss=%3")
-                        .arg(frameSize)
-                        .arg(encoder->FrameSize())
-                        .arg(pSoundStretch->numSamples()));
-
-                // process the same number of samples as it creates
-                // a full encoded buffer just like before
-                while (pSoundStretch->numSamples() >= frameSize)
-                {
-                    int got = pSoundStretch->receiveSamples(
-                        temp_buff, frameSize);
-                    int amount = encoder->Encode(temp_buff);
-
-                    VERBOSE(VB_AUDIO+VB_TIMESTAMP,
-                            QString("_AddSamples Enc bytes=%1 got=%2 left=%3")
-                            .arg(amount)
-                            .arg(got)
-                            .arg(pSoundStretch->numSamples()));
-
-                    if (!amount)
-                        continue;
-
-                    //len = WaitForFreeSpace(amount);
-                    char *ob = encoder->GetOutBuff();
-                    if (amount >= bdiff)
-                    {
-                        memcpy(audiobuffer + org_waud, ob, bdiff);
-                        ob += bdiff;
-                        amount -= bdiff;
-                        org_waud = 0;
-                    }
-                    if (amount > 0)
-                        memcpy(audiobuffer + org_waud, ob, amount);
-
-                    bdiff = kAudioRingBufferSize - amount;
-                    org_waud = (org_waud + amount) % kAudioRingBufferSize;
-                }
-            }
-            else
-            {
-                int newLen = 0;
-                int nSamples;
-                len = WaitForFreeSpace(pSoundStretch->numSamples() *
-                                       audio_bytes_per_sample);
-                do
-                {
-                    int samplesToGet = len/audio_bytes_per_sample;
-                    if (samplesToGet > nSamplesToEnd)
-                    {
-                        samplesToGet = nSamplesToEnd;
-                    }
-
-                    nSamples = pSoundStretch->receiveSamples(
-                        (soundtouch::SAMPLETYPE*)
-                        (audiobuffer + org_waud), samplesToGet);
-                    if (nSamples == nSamplesToEnd)
-                    {
-                        org_waud = 0;
-                        nSamplesToEnd = kAudioRingBufferSize/audio_bytes_per_sample;
-                    }
-                    else
-                    {
-                        int bufsz = nSamples * audio_bytes_per_sample;
-                        org_waud = (org_waud + bufsz) % kAudioRingBufferSize;
-                        nSamplesToEnd -= nSamples;
-                    }
-
-                    newLen += nSamples * audio_bytes_per_sample;
-                    len -= nSamples * audio_bytes_per_sample;
-                } while (nSamples > 0);
-            }
         }
+    }
 
-        waud = org_waud;
-        lastaudiolen = audiolen(false);
+    // Encode to AC-3? 
+    if (encoder) 
+    {
+        org_waud = waud;
+        int bdiff = kAudioRingBufferSize - org_waud;
+        int to_get = 0;
 
-        if (timecode < 0)
+        if (bdiff < len) 
         {
-            // mythmusic doesn't give timestamps..
-            timecode = (int)((samples_buffered * 100000.0) / effdsp);
+            encoder->Encode(audiobuffer + org_waud, bdiff);
+            to_get = encoder->Encode(audiobuffer, len - bdiff);
         }
- 
-        samples_buffered += samples;
- 
-        /* we want the time at the end -- but the file format stores
-           time at the start of the chunk. */
-        // even with timestretch, timecode is still calculated from original
-        // sample count
-        audbuf_timecode = timecode + (int)((samples * 100000.0) / effdsp);
+        else 
+            to_get = encoder->Encode(audiobuffer + org_waud, len);
 
-        if (interleaved)
+        if (to_get > 0) 
         {
-            dispatchVisual((unsigned char *)buffer, len, timecode,
-                           source_audio_channels, audio_bits);
+            if (to_get >= bdiff)
+            {
+                encoder->GetFrames(audiobuffer + org_waud, bdiff);
+                to_get -= bdiff;
+                org_waud = 0;
+            }
+            if (to_get > 0)
+                encoder->GetFrames(audiobuffer + org_waud, to_get);
+
+            org_waud += to_get;
         }
     }
 
-    audio_buflock.unlock();
+    waud = org_waud;
+    lastaudiolen = audiolen(false);
+
+    if (timecode < 0)
+        // mythmusic doesn't give timestamps..
+        timecode = (int)((samples_buffered * 100000.0) / effdsp);
+
+    samples_buffered += samples;
+
+    /* we want the time at the end -- but the file format stores
+       time at the start of the chunk. */
+    // even with timestretch, timecode is still calculated from original
+    // sample count
+    audbuf_timecode = timecode + (int)((samples * 100000.0) / effdsp);
 }
 
 void AudioOutputBase::Status()
Index: mythtv/libs/libmyth/audiooutput.cpp
===================================================================
--- mythtv/libs/libmyth/audiooutput.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiooutput.cpp	(working copy)
@@ -33,13 +33,14 @@
 AudioOutput *AudioOutput::OpenAudio(
     const QString &main_device,
     const QString &passthru_device,
-    int audio_bits, int audio_channels, int audio_samplerate,
+    int audio_bits, int audio_channels, 
+    int audio_codec, int audio_samplerate,
     AudioOutputSource source,
     bool set_initial_vol, bool audio_passthru)
 {
     AudioSettings settings(
         main_device, passthru_device, audio_bits,
-        audio_channels, audio_samplerate, source,
+        audio_channels, audio_codec, audio_samplerate, source,
         set_initial_vol, audio_passthru);
 
     settings.FixPassThrough();
Index: mythtv/libs/libmyth/audiosettings.h
===================================================================
--- mythtv/libs/libmyth/audiosettings.h	(revision 21594)
+++ mythtv/libs/libmyth/audiosettings.h	(working copy)
@@ -29,17 +29,17 @@
         const QString    &audio_passthru_device,
         int               audio_bits,
         int               audio_channels,
+        int               audio_codec,
         int               audio_samplerate,
         AudioOutputSource audio_source,
         bool              audio_set_initial_vol,
-        bool              audio_use_passthru,
-        void             *audio_codec = NULL);
+        bool              audio_use_passthru);
 
     AudioSettings(int   audio_bits, 
                   int   audio_channels, 
+                  int   audio_codec,
                   int   audio_samplerate,
-                  bool  audio_use_passthru,
-                  void *audio_codec = NULL);
+                  bool  audio_use_passthru);
 
     void FixPassThrough(void);
     void TrimDeviceType(void);
@@ -54,10 +54,10 @@
   public:
     int     bits;
     int     channels;
+    int     codec;
     int     samplerate;
     bool    set_initial_vol;
     bool    use_passthru;
-    void   *codec;
     AudioOutputSource source;
 };
 
Index: mythtv/libs/libmyth/audiooutputoss.cpp
===================================================================
--- mythtv/libs/libmyth/audiooutputoss.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputoss.cpp	(working copy)
@@ -42,6 +42,36 @@
     KillAudio();
 }
 
+vector<int> AudioOutputOSS::GetSupportedRates()
+{
+    const int srates[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
+    vector<int> rates(srates, srates + sizeof(srates) / sizeof(int) );
+    audiofd = open(audio_main_device.toAscii(), O_WRONLY | O_NONBLOCK);
+
+    if (audiofd < 0)
+    {
+        VERBOSE(VB_IMPORTANT, QString("Error opening audio device (%1), the"
+                " error was: %2").arg(audio_main_device).arg(strerror(errno)));
+        rates.clear();
+        return rates;
+    }
+
+    vector<int>::iterator it = rates.begin();
+
+    while (it != rates.end())
+    {
+        if(ioctl(audiofd, SNDCTL_DSP_SPEED, &audio_samplerate) < 0)
+            it = rates.erase(it);
+        else
+            it++;
+    }
+
+    close(audiofd);
+    audiofd = -1;
+
+    return rates;
+}
+
 bool AudioOutputOSS::OpenDevice()
 {
     numbadioctls = 0;
Index: mythtv/libs/libmyth/audiooutputdigitalencoder.cpp
===================================================================
--- mythtv/libs/libmyth/audiooutputdigitalencoder.cpp	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputdigitalencoder.cpp	(working copy)
@@ -32,9 +32,8 @@
 AudioOutputDigitalEncoder::AudioOutputDigitalEncoder(void) :
     audio_bytes_per_sample(0),
     av_context(NULL),
-    outbuf(NULL),
-    outbuf_size(0),
-    frame_buffer(NULL),
+    outbuflen(0),
+    inbuflen(0),
     one_frame_bytes(0)
 {
 }
@@ -52,20 +51,6 @@
         av_free(av_context);
         av_context = NULL;
     }
-
-    if (outbuf)
-    {
-        delete [] outbuf;
-        outbuf = NULL;
-        outbuf_size = 0;
-    }
-
-    if (frame_buffer)
-    {
-        delete [] frame_buffer;
-        frame_buffer = NULL;
-        one_frame_bytes = 0;
-    }
 }
 
 //CODEC_ID_AC3
@@ -80,8 +65,10 @@
             .arg(bitrate)
             .arg(samplerate)
             .arg(channels));
-
-    //codec = avcodec_find_encoder(codec_id);
+    
+    // We need to do this when called from mythmusic
+    avcodec_init();
+    avcodec_register_all();
     // always AC3 as there is no DTS encoder at the moment 2005/1/9
     codec = avcodec_find_encoder(CODEC_ID_AC3);
     if (!codec)
@@ -110,8 +97,6 @@
     audio_bytes_per_sample = bytes_per_frame;
     one_frame_bytes = bytes_per_frame * av_context->frame_size;
 
-    outbuf_size = 16384;    // ok for AC3 but DTS?
-    outbuf = new char [outbuf_size];
     VERBOSE(VB_AUDIO, QString("DigitalEncoder::Init fs=%1, bpf=%2 ofb=%3")
             .arg(av_context->frame_size)
             .arg(bytes_per_frame)
@@ -256,13 +241,27 @@
 
 } AESHeader;
 
+void reorder_6ch_ac3(void *buf, unsigned int len) {
+    unsigned short *src = (unsigned short *)buf;
+    unsigned short tmpC, tmpLFE;
+    unsigned int samples = len >> 1;
+
+    for (uint i = 0; i < samples; i += 6) {
+        tmpC = src[i+2];
+        tmpLFE = src[i+3];
+        src[i+2] = src[i+4];
+        src[i+3] = src[i+5];
+        src[i+4] = tmpC;
+        src[i+5] = tmpLFE;
+    }
+}
+
 static int encode_frame(
         bool dts, 
         unsigned char *data,
-        size_t &len)
+        size_t enc_len)
 {
     unsigned char *payload = data + 8;  // skip header, currently 52 or 54bits
-    size_t         enc_len;
     int            flags, sample_rate, bit_rate;
 
     // we don't do any length/crc validation of the AC3 frame here; presumably
@@ -273,7 +272,8 @@
     // ignore, and if so, may as well just assume that it will ignore
     // anything with a bad CRC...
 
-    uint nr_samples = 0, block_len;
+    uint nr_samples = 0, block_len = 0;
+
     if (dts)
     {
         enc_len = dts_syncinfo(payload, &flags, &sample_rate, &bit_rate);
@@ -302,13 +302,6 @@
         }
     }
 
-    if (enc_len == 0 || enc_len > len)
-    {
-        int l = len;
-        len = 0;
-        return l;
-    }
-
     enc_len = std::min((uint)enc_len, block_len - 8);
 
     //uint32_t x = *(uint32_t*)payload;
@@ -361,31 +354,44 @@
     data[6] = (enc_len << 3) & 0xFF;
     data[7] = (enc_len >> 5) & 0xFF;
     memset(payload + enc_len, 0, block_len - 8 - enc_len);
-    len = block_len;
 
     return enc_len;
 }
 
-// must have exactly 1 frames worth of data
-size_t AudioOutputDigitalEncoder::Encode(short *buff)
+size_t AudioOutputDigitalEncoder::Encode(void *buf, int len)
 {
-    int encsize = 0;
     size_t outsize = 0;
- 
-    // put data in the correct spot for encode frame
-    outsize = avcodec_encode_audio(
-        av_context, ((uchar*)outbuf) + 8, outbuf_size - 8, buff);
 
-    size_t tmpsize = outsize;
+    int fs = FrameSize();
+    memcpy(inbuf+inbuflen, buf, len);
+    inbuflen += len;
+    int frames = inbuflen / fs;
 
-    outsize = MAX_AC3_FRAME_SIZE;
-    encsize = encode_frame(
-        /*av_context->codec_id==CODEC_ID_DTS*/ false,
-        (unsigned char*)outbuf, outsize);
+    while (frames--) 
+    {
+        reorder_6ch_ac3(inbuf, fs);
 
-    VERBOSE(VB_AUDIO+VB_TIMESTAMP, 
-            QString("DigitalEncoder::Encode len1=%1 len2=%2 finallen=%3")
-                .arg(tmpsize).arg(encsize).arg(outsize));
+	// put data in the correct spot for encode frame
+        outsize = avcodec_encode_audio(
+            av_context, ((uchar*)outbuf) + outbuflen + 8, OUTBUFSIZE - 8, (short int *)inbuf);
 
-    return outsize;
+        encode_frame(
+            /*av_context->codec_id==CODEC_ID_DTS*/ false,
+            (unsigned char*)outbuf + outbuflen, outsize
+        );
+
+        outbuflen += MAX_AC3_FRAME_SIZE;
+        inbuflen -= fs;
+        memmove(inbuf, inbuf+fs, inbuflen);
+    }
+
+    return outbuflen;
 }
+
+void AudioOutputDigitalEncoder::GetFrames(void *ptr, int maxlen)
+{
+    int len = (maxlen < outbuflen ? maxlen : outbuflen);
+    memcpy(ptr, outbuf, len);
+    outbuflen -= len;
+    memmove(outbuf, outbuf+len, outbuflen);
+}
Index: mythtv/libs/libmyth/audiooutput.h
===================================================================
--- mythtv/libs/libmyth/audiooutput.h	(revision 21594)
+++ mythtv/libs/libmyth/audiooutput.h	(working copy)
@@ -15,7 +15,8 @@
     static AudioOutput *OpenAudio(
         const QString &audiodevice,
         const QString &passthrudevice,
-        int audio_bits, int audio_channels, int audio_samplerate,
+        int audio_bits, int audio_channels, 
+        int audio_codec, int audio_samplerate,
         AudioOutputSource source,
         bool set_initial_vol, bool audio_passthru);
 
@@ -68,6 +69,7 @@
     
     virtual void bufferOutputData(bool y) = 0;
     virtual int readOutputData(unsigned char *read_buffer, int max_length) = 0;
+    virtual bool ToggleUpmix(void) = 0;
 
   protected:
     void Error(const QString &msg);
Index: mythtv/libs/libmyth/audiooutputdigitalencoder.h
===================================================================
--- mythtv/libs/libmyth/audiooutputdigitalencoder.h	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputdigitalencoder.h	(working copy)
@@ -5,6 +5,9 @@
 #include "libavcodec/avcodec.h"
 };
 
+#define INBUFSIZE 131072
+#define OUTBUFSIZE 98304
+
 class AudioOutputDigitalEncoder
 {
   public:
@@ -13,29 +16,21 @@
 
     bool   Init(CodecID codec_id, int bitrate, int samplerate, int channels);
     void   Dispose(void);
-    size_t Encode(short * buff);
-
-    inline char *GetFrameBuffer(void);
+    size_t Encode(void *buf, int len);
+    void   GetFrames(void *ptr, int maxlen);
     size_t FrameSize(void)  const { return one_frame_bytes; }
-    char  *GetOutBuff(void) const { return outbuf;          }
+    int    Buffered(void) const { return inbuflen; }
 
   public:
     size_t audio_bytes_per_sample;
 
   private:
     AVCodecContext *av_context;
-    char           *outbuf;
-    int             outbuf_size;
-    char           *frame_buffer;
+    char            outbuf[OUTBUFSIZE];
+    char            inbuf[INBUFSIZE];
+    int             outbuflen;
+    int             inbuflen;
     size_t          one_frame_bytes;
 };
 
-inline char *AudioOutputDigitalEncoder::GetFrameBuffer(void)
-{
-    if (!frame_buffer && av_context)
-        frame_buffer = new char [one_frame_bytes];
-
-    return frame_buffer; 
-}
-
 #endif
Index: mythtv/libs/libmyth/audiooutputalsa.h
===================================================================
--- mythtv/libs/libmyth/audiooutputalsa.h	(revision 21594)
+++ mythtv/libs/libmyth/audiooutputalsa.h	(working copy)
@@ -65,14 +65,18 @@
     virtual void WriteAudio(unsigned char *aubuf, int size);
     virtual int  GetSpaceOnSoundcard(void) const;
     virtual int  GetBufferedOnSoundcard(void) const;
+    vector<int> GetSupportedRates(void);
 
   private:
+    void SetIECStatus(bool audio);
     inline int SetParameters(snd_pcm_t *handle,
                              snd_pcm_format_t format, unsigned int channels,
                              unsigned int rate, unsigned int buffer_time,
                              unsigned int period_time);
 
-
+    void ReorderSmpteToAlsa6ch(unsigned char *buf, int size);
+    template <class AudioDataType>
+        void _ReorderSmpteToAlsa6ch(AudioDataType *buf, int size);
     // Volume related
     void SetCurrentVolume(QString control, int channel, int volume);
     void OpenMixer(bool setstartingvolume);
Index: mythtv/libs/libmythfreesurround/el_processor.cpp
===================================================================
--- mythtv/libs/libmythfreesurround/el_processor.cpp	(revision 21594)
+++ mythtv/libs/libmythfreesurround/el_processor.cpp	(working copy)
@@ -26,7 +26,6 @@
 #include "fftw3.h"
 #else
 extern "C" {
-#include "libavutil/declare_aligned.h"
 #include "dsputil.h"
 };
 typedef FFTSample FFTComplexArray[2];
@@ -41,18 +40,8 @@
 
 const float PI = 3.141592654;
 const float epsilon = 0.000001;
-//const float center_level = 0.5*sqrt(0.5);   // gain of the center channel
-//const float center_level = sqrt(0.5);   // gain of the center channel
-const float center_level = 1.0;   // gain of the center channel
-//const float center_level = 0.5;   // gain of the center channel
+const float center_level = 0.5*sqrt(0.5);
 
-// should be .6-.7
-// but with centerlevel 2x what its supposed to be, we halve 0.68
-// to keep center from clipping
-//const float window_gain = 0.34;     
-//const float window_gain = 0.68;     
-const float window_gain = 0.95;     // to prive a bit of margin
-
 // private implementation of the surround decoder
 class decoder_impl {
 public:
@@ -99,19 +88,11 @@
             outbuf[c].resize(N);
             filter[c].resize(N);
         }
-        // DC component of filters is always 0
-        for (unsigned c=0;c<5;c++)
-        {
-            filter[c][0] = 0.0;
-            filter[c][1] = 0.0;
-            filter[c][halfN] = 0.0;
-        }
         sample_rate(48000);
         // generate the window function (square root of hann, b/c it is applied before and after the transform)
         wnd.resize(N);
-        // dft normalization included in the window for zero cost scaling
-        // also add a gain factor of *2 due to processing gain in algo (see center_level)
-        surround_gain(1.0);
+        for (unsigned k=0;k<N;k++)
+            wnd[k] = sqrt(0.5*(1-cos(2*PI*k/N))/N);
         current_buf = 0;
         // set the default coefficients
         surround_coefficients(0.8165,0.5774);
@@ -193,10 +174,10 @@
     // set lfe filter params
     void sample_rate(unsigned int srate) {
         // lfe filter is just straight through band limited
-        unsigned int cutoff = (250*N)/srate;
+        unsigned int cutoff = (30*N)/srate;
         for (unsigned f=0;f<=halfN;f++) {           
-            if ((f>=2) && (f<cutoff))
-                filter[5][f] = 1.0;
+            if (f<cutoff)
+                filter[5][f] = 0.5*sqrt(0.5);
             else
                 filter[5][f] = 0.0;
         }
@@ -215,12 +196,6 @@
         E = (o+v)*n; F = (o+u)*n; G = (o-v)*n;  H = (o-u)*n;
     }
 
-    void surround_gain(float gain) {
-        master_gain = gain * window_gain * 0.5 * 0.25;
-        for (unsigned k=0;k<N;k++)
-            wnd[k] = sqrt(master_gain*(1-cos(2*PI*k/N))/N);
-    }
-
     // set the phase shifting mode
     void phase_mode(unsigned mode) {
         const float modes[4][2] = {{0,0},{0,PI},{PI,0},{-PI/2,PI/2}};
@@ -291,7 +266,7 @@
 
         // 2. compare amplitude and phase of each DFT bin and produce the X/Y coordinates in the sound field
         //    but dont do DC or N/2 component
-        for (unsigned f=2;f<halfN;f++) {           
+        for (unsigned f=0;f<halfN;f++) {           
             // get left/right amplitudes/phases
             float ampL = amplitude(dftL[f]), ampR = amplitude(dftR[f]);
             float phaseL = phase(dftL[f]), phaseR = phase(dftR[f]);
@@ -306,41 +281,6 @@
             phaseDiff = abs(phaseDiff);
 
             if (linear_steering) {
-/*              cfloat w = polar(sqrt(ampL*ampL+ampR*ampR), (phaseL+phaseR)/2);
-                cfloat lt = cfloat(dftL[f][0],dftL[f][1])/w, rt = cfloat(dftR[f][0],dftR[f][1])/w;              */
-//              xfs[f] = -(C*(rt-H) - B*E + F*A + G*(D-lt)) / (G*A - C*E).real();
-//              yfs[f] = (rt - (xfs[f]*E+H))/(F+xfs[f]*G);
-
-                /*
-                Problem: 
-                This assumes that the values are interpolated linearly between the cardinal points.
-                But this way we have no chance of knowing the average volume...
-                - Can we solve that computing everything under the assumption of normalized volume?
-                  No. Seemingly not.
-                - Maybe we should add w explitcitly into the equation and see if we can solve it...
-                */
-
-
-                //cfloat lt(0.5,0),rt(0.5,0);
-                //cfloat x(0,0), y(1,0);
-                /*cfloat p = (C*(rt-H) - B*E + F*A + G*(D-lt)) / (G*A - C*E);
-                cfloat q = B*(rt+H) + F*(D-lt) / (G*A - C*E);
-                cfloat s = sqrt(p*p/4.0f - q);
-                cfloat x = -p;
-                cfloat x1 = -p/2.0f + s;
-                cfloat x2 = -p/2.0f - s;
-                float x = 0;
-                if (x1.real() >= -1 && x1.real() <= 1)
-                    x = x1.real();
-                else if (x2.real() >= -1 && x2.real() <= 1)
-                    x = x2.real();*/
-
-                //cfloat yp = (rt - (x*E+H))/(F+x*G);
-                //cfloat xp = (lt - (y*B+D))/(A+y*C);
-
-                /*xfs[f] = x;
-                yfs[f] = y.real();*/
-
                 // --- this is the fancy new linear mode ---
 
                 // get sound field x/y position
@@ -598,7 +538,6 @@
     float surround_high,surround_low;  // high and low surround mixing coefficient (e.g. 0.8165/0.5774)
     float surround_balance;            // the xfs balance that follows from the coeffs
     float surround_level;              // gain for the surround channels (follows from the coeffs
-    float master_gain;                 // gain for all channels
     float phase_offsetL, phase_offsetR;// phase shifts to be applied to the rear channels
     float front_separation;            // front stereo separation
     float rear_separation;             // rear stereo separation
@@ -626,8 +565,6 @@
 
 void fsurround_decoder::surround_coefficients(float a, float b) { impl->surround_coefficients(a,b); }
 
-void fsurround_decoder::gain(float gain) { impl->surround_gain(gain); }
-
 void fsurround_decoder::phase_mode(unsigned mode) { impl->phase_mode(mode); }
 
 void fsurround_decoder::steering_mode(bool mode) { impl->steering_mode(mode); }
Index: mythtv/libs/libmythfreesurround/freesurround.cpp
===================================================================
--- mythtv/libs/libmythfreesurround/freesurround.cpp	(revision 21594)
+++ mythtv/libs/libmythfreesurround/freesurround.cpp	(working copy)
@@ -63,10 +63,9 @@
 const unsigned default_block_size = 8192;
 // there will be a slider for this in the future
 //const float master_gain = 1.0;
-//#define MASTER_GAIN * master_gain
+//#define MASTER_GAIN * master_gain 
 #define MASTER_GAIN
-//const float master_gain = 1.0/(1<<15);
-//const float inv_master_gain = (1<<15);
+//const float inv_master_gain = 1.0;
 //#define INV_MASTER_GAIN * inv_master_gain
 #define INV_MASTER_GAIN
 
@@ -192,15 +191,13 @@
     if (moviemode)
     {
         params.phasemode = 1;
-        params.center_width = 0;
-        params.gain = 1.0;
+        params.center_width = 25;
+        params.dimension = 0.5;
     }
     else
     {
-        params.center_width = 70;
-        // for 50, gain should be about 1.9, c/lr about 2.7
-        // for 70, gain should be about 3.1, c/lr about 1.5
-        params.gain = 3.1;
+        params.center_width = 65;
+        params.dimension = 0.3;
     }
     switch (surround_mode)
     {
@@ -236,7 +233,6 @@
         decoder->phase_mode(params.phasemode);
         decoder->surround_coefficients(params.coeff_a, params.coeff_b);				
         decoder->separation(params.front_sep/100.0,params.rear_sep/100.0);
-        decoder->gain(params.gain);
     }
 }
 
@@ -250,8 +246,7 @@
     phasemode(0),
     steering(1),
     front_sep(100),
-    rear_sep(100), 
-    gain(1.0)
+    rear_sep(100) 
 {
 }
 
@@ -329,11 +324,11 @@
                     for (i=0;(i<numSamples) && (ic < bs);i++,ic++)
                     {
                         int16bufs->l[ic] = *samples++ >> 1;
-                        int16bufs->c[ic] = *samples++ >> 1;
                         int16bufs->r[ic] = *samples++ >> 1;
+                        int16bufs->c[ic] = *samples++ >> 1;
+                        int16bufs->lfe[ic] = *samples++ >> 1;
                         int16bufs->ls[ic] = *samples++ >> 1;
                         int16bufs->rs[ic] = *samples++ >> 1;
-                        int16bufs->lfe[ic] = *samples++ >> 1;
                     }
                     break;
             }
@@ -391,11 +386,11 @@
                         for (i=0;i<numSamples;i++)
                         {
                             *l++ = *samples++ >> 1;
-                            *c++ = *samples++ >> 1;
                             *r++ = *samples++ >> 1;
+                            *c++ = *samples++ >> 1;
+                            *lfe++ = *samples++ >> 1;
                             *ls++ = *samples++ >> 1;
                             *rs++ = *samples++ >> 1;
-                            *lfe++ = *samples++ >> 1;
                         }
                         } break;
                 }
@@ -479,11 +474,11 @@
                     for (i=0;(i<numSamples) && (ic < bs);i++,ic++)
                     {
                         int16bufs->l[ic] = *samples++ << 7;
-                        int16bufs->c[ic] = *samples++ << 7;
                         int16bufs->r[ic] = *samples++ << 7;
+                        int16bufs->c[ic] = *samples++ << 7;
+                        int16bufs->lfe[ic] = *samples++ << 7;
                         int16bufs->ls[ic] = *samples++ << 7;
                         int16bufs->rs[ic] = *samples++ << 7;
-                        int16bufs->lfe[ic] = *samples++ << 7;
                     }
                     break;
             }
@@ -541,11 +536,11 @@
                         for (i=0;i<numSamples;i++)
                         {
                             *l++ = *samples++ << 7;
-                            *c++ = *samples++ << 7;
                             *r++ = *samples++ << 7;
+                            *c++ = *samples++ << 7;
+                            *lfe++ = *samples++ << 7;
                             *ls++ = *samples++ << 7;
                             *rs++ = *samples++ << 7;
-                            *lfe++ = *samples++ << 7;
                         }
                         } break;
                 }
@@ -655,16 +650,6 @@
     {
         if (decoder) 
         {
-            // actually these params need only be set when they change... but it doesn't hurt
-#if 0
-            decoder->steering_mode(params.steering);
-            decoder->phase_mode(params.phasemode);
-            decoder->surround_coefficients(params.coeff_a, params.coeff_b);				
-            decoder->separation(params.front_sep/100.0,params.rear_sep/100.0);
-#endif
-            // decode the bufs->block
-            //decoder->decode(input,output,params.center_width/100.0,params.dimension/100.0);
-            //decoder->decode(output,params.center_width/100.0,params.dimension/100.0);
             decoder->decode(params.center_width/100.0,params.dimension/100.0);
         }
     }
Index: mythtv/libs/libmythfreesurround/el_processor.h
===================================================================
--- mythtv/libs/libmythfreesurround/el_processor.h	(revision 21594)
+++ mythtv/libs/libmythfreesurround/el_processor.h	(working copy)
@@ -47,14 +47,11 @@
 	//  a is the coefficient of left rear in left total, b is the coefficient of left rear in right total; the same is true for right.
 	void surround_coefficients(float a, float b);
 
-	// override for master surround gain
-	void gain(float gain);
-
 	// set the phase shifting mode for decoding
-	// 0 = (+0,+0)   - music mode
-	// 1 = (+0,+180) - PowerDVD compatibility
-	// 2 = (+180,+0) - BeSweet compatibility
-	// 3 = (-90,+90) - This seems to work. I just don't know why.
+	// 0 = (+0,+0)   - music mode
+	// 1 = (+0,+180) - PowerDVD compatibility
+	// 2 = (+180,+0) - BeSweet compatibility
+	// 3 = (-90,+90) - This seems to work. I just don't know why.
 	void phase_mode(unsigned mode);
 
 	// override the steering mode
Index: mythtv/programs/mythfrontend/globalsettings.cpp
===================================================================
--- mythtv/programs/mythfrontend/globalsettings.cpp	(revision 21594)
+++ mythtv/programs/mythfrontend/globalsettings.cpp	(working copy)
@@ -121,6 +121,27 @@
     return gc;
 }
 
+static HostComboBox *SRCQuality()
+{
+    HostComboBox *gc = new HostComboBox("SRCQuality", false);
+    gc->setLabel(QObject::tr("Sample Rate Conversion"));
+    gc->addSelection(QObject::tr("Best"), "3", true); // default
+    gc->addSelection(QObject::tr("Medium"), "2");
+    gc->addSelection(QObject::tr("Fastest"), "1");
+    gc->setHelpText(
+            QObject::tr(
+                "Set the quality of audio sample rate conversion. "
+                "This only affects non 48000Hz PCM audio. "
+                "All three options offer a worst-case SNR of 97dB. "
+                "'Best' at a bandwidth of 97%. "
+                "'Medium' at a bandwidth of 90%. "
+                "'Fastest' at a bandwidth of 80%. "
+            )
+    );
+    return gc;
+}
+
+
 static HostComboBox *PassThroughOutputDevice()
 {
     HostComboBox *gc = new HostComboBox("PassThruOutputDevice", true);
@@ -3524,6 +3545,7 @@
 
         addChild(MaxAudioChannels());
         addChild(AudioUpmixType());
+        addChild(SRCQuality());
 
         // General boolean settings
         addChild(AC3PassThrough());
Index: mythtv/programs/mythtranscode/transcode.cpp
===================================================================
--- mythtv/programs/mythtranscode/transcode.cpp	(revision 21594)
+++ mythtv/programs/mythtranscode/transcode.cpp	(working copy)
@@ -49,7 +49,7 @@
     AudioReencodeBuffer(int audio_bits, int audio_channels)
     {
         Reset();
-        const AudioSettings settings(audio_bits, audio_channels, 0, false);
+        const AudioSettings settings(audio_bits, audio_channels, 0, 0, false);
         Reconfigure(settings);
         bufsize = 512000;
         audiobuffer = new unsigned char[bufsize];
@@ -222,6 +222,11 @@
         // Do nothing
         return kMuteOff;
     }
+    virtual bool ToggleUpmix(void) 
+    {
+        // Do nothing
+        return false;
+    }
 
     //  These are pure virtual in AudioOutput, but we don't need them here
     virtual void bufferOutputData(bool){ return; }
