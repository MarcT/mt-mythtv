diff --git a/mythtv/libs/libmyth/audiooutput.cpp b/mythtv/libs/libmyth/audiooutput.cpp
index 2d131fb..21fbcc0 100644
--- a/mythtv/libs/libmyth/audiooutput.cpp
+++ b/mythtv/libs/libmyth/audiooutput.cpp
@@ -31,14 +31,16 @@ using namespace std;
 AudioOutput *AudioOutput::OpenAudio(
     const QString &main_device,
     const QString &passthru_device,
-    int audio_bits, int audio_channels, int audio_samplerate,
+    int audio_bits, int audio_channels, 
+    int audio_codec, int audio_samplerate,
     AudioOutputSource source,
-    bool set_initial_vol, bool audio_passthru)
+    bool set_initial_vol, bool audio_passthru,
+    int upmixer_startup)
 {
     AudioSettings settings(
         main_device, passthru_device, audio_bits,
-        audio_channels, audio_samplerate, source,
-        set_initial_vol, audio_passthru);
+        audio_channels, audio_codec, audio_samplerate, source,
+        set_initial_vol, audio_passthru, upmixer_startup);
 
     settings.FixPassThrough();
 
diff --git a/mythtv/libs/libmyth/audiooutput.h b/mythtv/libs/libmyth/audiooutput.h
index 943bd77..e89147c 100644
--- a/mythtv/libs/libmyth/audiooutput.h
+++ b/mythtv/libs/libmyth/audiooutput.h
@@ -15,9 +15,11 @@ class MPUBLIC AudioOutput : public VolumeBase, public OutputListeners
     static AudioOutput *OpenAudio(
         const QString &audiodevice,
         const QString &passthrudevice,
-        int audio_bits, int audio_channels, int audio_samplerate,
+        int audio_bits, int audio_channels, 
+        int audio_codec, int audio_samplerate,
         AudioOutputSource source,
-        bool set_initial_vol, bool audio_passthru);
+        bool set_initial_vol, bool audio_passthru,
+        int upmixer_startup = 0);
 
     AudioOutput() :
         VolumeBase(),             OutputListeners(),
@@ -68,6 +70,7 @@ class MPUBLIC AudioOutput : public VolumeBase, public OutputListeners
     
     virtual void bufferOutputData(bool y) = 0;
     virtual int readOutputData(unsigned char *read_buffer, int max_length) = 0;
+    virtual bool ToggleUpmix(void) = 0;
 
   protected:
     void Error(const QString &msg);
diff --git a/mythtv/libs/libmyth/audiooutputalsa.cpp b/mythtv/libs/libmyth/audiooutputalsa.cpp
index 99a9cee..2f55977 100644
--- a/mythtv/libs/libmyth/audiooutputalsa.cpp
+++ b/mythtv/libs/libmyth/audiooutputalsa.cpp
@@ -32,6 +32,117 @@ AudioOutputALSA::AudioOutputALSA(const AudioSettings &settings) :
 AudioOutputALSA::~AudioOutputALSA()
 {
     KillAudio();
+    SetIECStatus(true);
+}
+
+void AudioOutputALSA::SetIECStatus(bool audio)
+{
+    snd_ctl_t *ctl;
+    const char *spdif_str = SND_CTL_NAME_IEC958("", PLAYBACK, DEFAULT);
+    int spdif_index = -1;
+    snd_ctl_elem_list_t *clist;
+    snd_ctl_elem_id_t *cid;
+    snd_ctl_elem_value_t *cval;
+    snd_aes_iec958_t iec958;
+    int cidx, controls;
+
+    VERBOSE(VB_AUDIO, QString("Setting IEC958 status: %1")
+                      .arg(audio ? "audio" : "non-audio"));
+
+    int err;
+    if ((err = snd_ctl_open(&ctl, "default", 0)) < 0)
+    {
+        Error(QString("AudioOutputALSA::SetIECStatus: snd_ctl_open(default): %1")
+              .arg(snd_strerror(err)));
+        return;
+    }
+    snd_ctl_elem_list_alloca(&clist);
+    snd_ctl_elem_list(ctl, clist);
+    snd_ctl_elem_list_alloc_space(clist, snd_ctl_elem_list_get_count(clist));
+    snd_ctl_elem_list(ctl, clist);
+    controls = snd_ctl_elem_list_get_used(clist);
+    for (cidx = 0; cidx < controls; cidx++)
+    {
+        if (!strcmp(snd_ctl_elem_list_get_name(clist, cidx), spdif_str))
+            if (spdif_index < 0 ||
+                snd_ctl_elem_list_get_index(clist, cidx) == (uint)spdif_index)
+                    break;
+    }
+
+    if (cidx >= controls)
+        return;
+
+    snd_ctl_elem_id_alloca(&cid);
+    snd_ctl_elem_list_get_id(clist, cidx, cid);
+    snd_ctl_elem_value_alloca(&cval);
+    snd_ctl_elem_value_set_id(cval, cid);
+    snd_ctl_elem_read(ctl,cval);
+    snd_ctl_elem_value_get_iec958(cval, &iec958);
+
+    if (!audio) 
+        iec958.status[0] |= IEC958_AES0_NONAUDIO;
+    else
+        iec958.status[0] &= ~IEC958_AES0_NONAUDIO;
+
+    snd_ctl_elem_value_set_iec958(cval, &iec958);
+    snd_ctl_elem_write(ctl, cval);
+}
+
+vector<int> AudioOutputALSA::GetSupportedRates()
+{
+    snd_pcm_hw_params_t *params;
+    int err;
+    const int srates[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
+    vector<int> rates(srates, srates + sizeof(srates) / sizeof(int) );
+    QString real_device;
+    
+    if (audio_passthru || audio_enc)
+        real_device = audio_passthru_device;
+    else 
+        real_device = audio_main_device;
+
+    if((err = snd_pcm_open(&pcm_handle, real_device.toAscii(),
+                           SND_PCM_STREAM_PLAYBACK, 
+                           SND_PCM_NONBLOCK|SND_PCM_NO_AUTO_RESAMPLE)) < 0)
+    { 
+        Error(QString("snd_pcm_open(%1): %2")
+              .arg(real_device).arg(snd_strerror(err)));
+
+        if (pcm_handle)
+        {
+            snd_pcm_close(pcm_handle);
+            pcm_handle = NULL;
+        }
+        rates.clear();
+        return rates;
+    }
+    
+    snd_pcm_hw_params_alloca(&params);
+
+    if ((err = snd_pcm_hw_params_any(pcm_handle, params)) < 0)
+    {
+        Error(QString("Broken configuration for playback; no configurations"
+              " available: %1").arg(snd_strerror(err)));
+        snd_pcm_close(pcm_handle);
+        pcm_handle = NULL;
+        rates.clear();
+        return rates;
+    }
+    
+    vector<int>::iterator it = rates.begin();
+
+    while (it != rates.end())
+    {
+        if(snd_pcm_hw_params_test_rate(pcm_handle, params, *it, 0) < 0)
+            it = rates.erase(it);
+        else
+            it++;
+    }
+    
+    snd_pcm_close(pcm_handle);
+    pcm_handle = NULL;
+
+    return rates;
 }
 
 bool AudioOutputALSA::OpenDevice()
@@ -39,6 +150,7 @@ bool AudioOutputALSA::OpenDevice()
     snd_pcm_format_t format;
     unsigned int buffer_time, period_time;
     int err;
+    QString real_device;
 
     if (pcm_handle != NULL)
         CloseDevice();
@@ -46,8 +158,16 @@ bool AudioOutputALSA::OpenDevice()
     pcm_handle = NULL;
     numbadioctls = 0;
 
-    QString real_device = (audio_passthru) ?
-        audio_passthru_device : audio_main_device;
+    if (audio_passthru || audio_enc)
+    {
+        real_device = audio_passthru_device;
+        SetIECStatus(false);
+    }
+    else 
+    {
+        real_device = audio_main_device;
+        SetIECStatus(true);
+    }
 
     VERBOSE(VB_GENERAL, QString("Opening ALSA audio device '%1'.")
             .arg(real_device));
@@ -146,7 +266,29 @@ void AudioOutputALSA::CloseDevice()
     }
 }
 
+void AudioOutputALSA::ReorderSmpteToAlsa6ch(unsigned char *buf, int size) 
+{
+    if (audio_bits == 8)
+        _ReorderSmpteToAlsa6ch(buf, size);
+    else if (audio_bits == 16)
+        _ReorderSmpteToAlsa6ch((short *)buf, size / sizeof(short));
+}
+
+template <class AudioDataType>
+void AudioOutputALSA::_ReorderSmpteToAlsa6ch(AudioDataType *buf, int size) 
+{
+    AudioDataType tmpC, tmpLFE;
+
+    for (int i = 0; i < size; i+= 6) {
+        tmpC = buf[i+2];
+        tmpLFE = buf[i+3];
+        buf[i+2] = buf[i+4];
+        buf[i+3] = buf[i+5];
+        buf[i+4] = tmpC;
+        buf[i+5] = tmpLFE;
+    }
 
+}
 void AudioOutputALSA::WriteAudio(unsigned char *aubuf, int size)
 {
     unsigned char *tmpbuf;
@@ -158,6 +300,9 @@ void AudioOutputALSA::WriteAudio(unsigned char *aubuf, int size)
         VERBOSE(VB_IMPORTANT, QString("WriteAudio() called with pcm_handle == NULL!"));
         return;
     }
+
+    if (!(audio_passthru || audio_enc) && audio_channels == 6)
+        ReorderSmpteToAlsa6ch(aubuf, size);
     
     tmpbuf = aubuf;
 
@@ -634,6 +779,9 @@ void AudioOutputALSA::SetupMixer(void)
     if (mixer_handle != NULL)
         CloseMixer();
 
+    if (alsadevice.toLower() == "software")
+        return;
+
     VERBOSE(VB_AUDIO, QString("Opening mixer %1").arg(device));
 
     // TODO: This is opening card 0. Fix for case of multiple soundcards
diff --git a/mythtv/libs/libmyth/audiooutputalsa.h b/mythtv/libs/libmyth/audiooutputalsa.h
index a156edd..fb609e9 100644
--- a/mythtv/libs/libmyth/audiooutputalsa.h
+++ b/mythtv/libs/libmyth/audiooutputalsa.h
@@ -65,14 +65,18 @@ class AudioOutputALSA : public AudioOutputBase
     virtual void WriteAudio(unsigned char *aubuf, int size);
     virtual int  GetSpaceOnSoundcard(void) const;
     virtual int  GetBufferedOnSoundcard(void) const;
+    vector<int> GetSupportedRates(void);
 
   private:
+    void SetIECStatus(bool audio);
     inline int SetParameters(snd_pcm_t *handle,
                              snd_pcm_format_t format, unsigned int channels,
                              unsigned int rate, unsigned int buffer_time,
                              unsigned int period_time);
 
-
+    void ReorderSmpteToAlsa6ch(unsigned char *buf, int size);
+    template <class AudioDataType>
+        void _ReorderSmpteToAlsa6ch(AudioDataType *buf, int size);
     // Volume related
     void SetCurrentVolume(QString control, int channel, int volume);
     void OpenMixer(bool setstartingvolume);
diff --git a/mythtv/libs/libmyth/audiooutputbase.cpp b/mythtv/libs/libmyth/audiooutputbase.cpp
index 80f3110..9c2df63 100644
--- a/mythtv/libs/libmyth/audiooutputbase.cpp
+++ b/mythtv/libs/libmyth/audiooutputbase.cpp
@@ -1,5 +1,6 @@
 // Std C headers
 #include <cmath>
+#include <limits>
 
 // POSIX headers
 #include <unistd.h>
@@ -21,16 +22,16 @@
 AudioOutputBase::AudioOutputBase(const AudioSettings &settings) :
     // protected
     effdsp(0),                  effdspstretched(0),
-    audio_channels(-1),         audio_bytes_per_sample(0),
-    audio_bits(-1),             audio_samplerate(-1),
-    audio_buffer_unused(0),
+    audio_channels(-1),         audio_codec(CODEC_ID_NONE),
+    audio_bytes_per_sample(0),  audio_bits(-1),
+    audio_samplerate(-1),       audio_buffer_unused(0),
     fragment_size(0),           soundcard_buffer_size(0),
 
     audio_main_device(settings.GetMainDevice()),
     audio_passthru_device(settings.GetPassthruDevice()),
-    audio_passthru(false),      audio_stretchfactor(1.0f),
+    audio_passthru(false),      audio_enc(false),
+    audio_reenc(false),         audio_stretchfactor(1.0f),
 
-    audio_codec(NULL),
     source(settings.source),    killaudio(false),
 
     pauseaudio(false),          audio_actually_paused(false),
@@ -48,9 +49,12 @@ AudioOutputBase::AudioOutputBase(const AudioSettings &settings) :
     encoder(NULL),
     upmixer(NULL),
     source_audio_channels(-1),
+    source_audio_samplerate(0),
     source_audio_bytes_per_sample(0),
     needs_upmix(false),
     surround_mode(FreeSurround::SurroundModePassive),
+    old_audio_stretchfactor(1.0),
+    volume(80),
 
     blocking(false),
 
@@ -62,7 +66,7 @@ AudioOutputBase::AudioOutputBase(const AudioSettings &settings) :
     raud(0),                    waud(0),
     audbuf_timecode(0),
 
-    numlowbuffer(0),            killAudioLock(QMutex::NonRecursive),
+    killAudioLock(QMutex::NonRecursive),
     current_seconds(-1),        source_bitrate(-1),
 
     memory_corruption_test0(0xdeadbeef),
@@ -78,7 +82,17 @@ AudioOutputBase::AudioOutputBase(const AudioSettings &settings) :
     memset(tmp_buff,           0, sizeof(short) * kAudioTempBufSize);
     memset(&audiotime_updated, 0, sizeof(audiotime_updated));
     memset(audiobuffer,        0, sizeof(char)  * kAudioRingBufferSize);
-    configured_audio_channels = gContext->GetNumSetting("MaxChannels", 2);
+    orig_config_channels = gContext->GetNumSetting("MaxChannels", 2);
+    src_quality = gContext->GetNumSetting("AudioUpmixType", 2);
+    if (!settings.upmixer)
+        configured_audio_channels = gContext->GetNumSetting("AudioDefaultUpmix", false) ? orig_config_channels : 2;
+    else
+        if (settings.upmixer == 1)
+            configured_audio_channels = 2;
+        else
+            configured_audio_channels = 6;
+
+    allow_ac3_passthru = (orig_config_channels > 2) ? gContext->GetNumSetting("AC3PassThru", false) : false;
 
     // You need to call Reconfigure from your concrete class.
     // Reconfigure(laudio_bits,       laudio_channels,
@@ -124,40 +138,9 @@ void AudioOutputBase::SetStretchFactorLocked(float laudio_stretchfactor)
             VERBOSE(VB_GENERAL, LOC + QString("Using time stretch %1")
                                         .arg(audio_stretchfactor));
             pSoundStretch = new soundtouch::SoundTouch();
-            if (audio_codec)
-            {
-                if (!encoder)
-                {
-                    VERBOSE(VB_AUDIO, LOC +
-                            QString("Creating Encoder for codec %1 origfs %2")
-                            .arg(audio_codec->codec_id)
-                            .arg(audio_codec->frame_size));
-
-                    encoder = new AudioOutputDigitalEncoder();
-                    if (!encoder->Init(audio_codec->codec_id,
-                                audio_codec->bit_rate,
-                                audio_codec->sample_rate,
-                                audio_codec->channels
-                                ))
-                    {
-                        // eeks
-                        delete encoder;
-                        encoder = NULL;
-                        VERBOSE(VB_AUDIO, LOC +
-                                QString("Failed to Create Encoder"));
-                    }
-                }
-            }
-            if (audio_codec && encoder)
-            {
-                pSoundStretch->setSampleRate(audio_codec->sample_rate);
-                pSoundStretch->setChannels(audio_codec->channels);
-            }
-            else
-            {
-                pSoundStretch->setSampleRate(audio_samplerate);
-                pSoundStretch->setChannels(audio_channels);
-            }
+            pSoundStretch->setSampleRate(audio_samplerate);
+            pSoundStretch->setChannels(upmixer ? 
+                configured_audio_channels : source_audio_channels);
 
             pSoundStretch->setTempo(audio_stretchfactor);
             pSoundStretch->setSetting(SETTING_SEQUENCE_MS, 35);
@@ -165,7 +148,6 @@ void AudioOutputBase::SetStretchFactorLocked(float laudio_stretchfactor)
             // dont need these with only tempo change
             //pSoundStretch->setPitch(1.0);
             //pSoundStretch->setRate(1.0);
-
             //pSoundStretch->setSetting(SETTING_USE_QUICKSEEK, true);
             //pSoundStretch->setSetting(SETTING_USE_AA_FILTER, false);
         }
@@ -183,35 +165,43 @@ float AudioOutputBase::GetStretchFactor(void) const
     return audio_stretchfactor;
 }
 
+bool AudioOutputBase::ToggleUpmix(void)
+{
+    if (orig_config_channels == 2 || source_audio_channels > 2 ||
+        audio_passthru)
+        return false;
+    if (configured_audio_channels == 6)
+        configured_audio_channels = 2;
+    else
+        configured_audio_channels = 6;
+
+    const AudioSettings settings(audio_bits, source_audio_channels,
+                                 audio_codec, source_audio_samplerate,
+                                 audio_passthru);
+    Reconfigure(settings);
+    return (configured_audio_channels == 6);
+}
+
+
 void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
 {
     AudioSettings settings = orig_settings;
 
-    int codec_id = CODEC_ID_NONE;
-    int lcodec_id = CODEC_ID_NONE;
-    int lcchannels = 0;
-    int cchannels = 0;
     int lsource_audio_channels = settings.channels;
     bool lneeds_upmix = false;
+    bool laudio_reenc = false;
 
-    if (settings.codec)
+    // Are we reencoding a (previously) timestretched bitstream?
+    if ((settings.codec == CODEC_ID_AC3 || settings.codec == CODEC_ID_DTS) &&
+        !settings.use_passthru && allow_ac3_passthru)
     {
-        lcodec_id = ((AVCodecContext*)settings.codec)->codec_id;
-        settings.bits = 16;
-        settings.channels = 2;
-        lsource_audio_channels = settings.channels;
-        settings.samplerate = 48000;
-        lcchannels = ((AVCodecContext*)settings.codec)->channels;
+        laudio_reenc = true;
+        VERBOSE(VB_AUDIO, LOC + "Reencoding decoded AC3/DTS to AC3");
     }
 
-    if (audio_codec)
-    {
-        codec_id = audio_codec->codec_id;
-        cchannels = ((AVCodecContext*)audio_codec)->channels;
-    }
-
-    if ((configured_audio_channels == 6) &&
-        !(settings.codec || audio_codec))
+    // Enough channels? Upmix if not
+    if (settings.channels < configured_audio_channels &&
+        !settings.use_passthru)
     {
         settings.channels = configured_audio_channels;
         lneeds_upmix = true;
@@ -224,7 +214,7 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
         settings.samplerate == audio_samplerate && !need_resampler &&
         settings.use_passthru == audio_passthru &&
         lneeds_upmix == needs_upmix &&
-        lcodec_id == codec_id && lcchannels == cchannels);
+        laudio_reenc == audio_reenc);
     bool upmix_deps =
         (lsource_audio_channels == source_audio_channels);
     if (general_deps && upmix_deps)
@@ -251,12 +241,12 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
     waud = raud = 0;
     audio_actually_paused = false;
 
-    bool redo_stretch = (pSoundStretch && audio_channels != settings.channels);
     audio_channels = settings.channels;
     source_audio_channels = lsource_audio_channels;
     audio_bits = settings.bits;
-    audio_samplerate = settings.samplerate;
-    audio_codec = (AVCodecContext*)settings.codec;
+    source_audio_samplerate = audio_samplerate = settings.samplerate;
+    audio_reenc = laudio_reenc;
+    audio_codec = settings.codec;
     audio_passthru = settings.use_passthru;
     needs_upmix = lneeds_upmix;
 
@@ -265,8 +255,9 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
         Error("AudioOutput only supports 8 or 16bit audio.");
         return;
     }
-    audio_bytes_per_sample = audio_channels * audio_bits / 8;
-    source_audio_bytes_per_sample = source_audio_channels * audio_bits / 8;
+    
+    VERBOSE(VB_AUDIO, LOC + QString("Original audio codec was %1")
+                            .arg(codec_id_string((CodecID)audio_codec)));
 
     need_resampler = false;
     killaudio = false;
@@ -274,11 +265,71 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
     was_paused = true;
     internal_vol = gContext->GetNumSetting("MythControlsVolume", 0);
 
-    numlowbuffer = 0;
+    // Find out what sample rates we can output (if output layer supports it)
+    vector<int> rates = GetSupportedRates();
+    vector<int>::iterator it;
+    bool resample = true;
+
+    for (it = rates.begin(); it < rates.end(); it++)
+    {
+        VERBOSE(VB_AUDIO, LOC + QString("Sample rate %1 is supported")
+                                .arg(*it));
+        if (*it == audio_samplerate)
+            resample = false;
+    }
+
+    // Assume 48k if we can't get supported rates
+    if (rates.empty())
+        rates.push_back(48000);
 
-    VERBOSE(VB_GENERAL, QString("Opening audio device '%1'. ch %2(%3) sr %4")
+    if (resample)
+    {
+        int error;
+        audio_samplerate = *(rates.end());
+        VERBOSE(VB_GENERAL, LOC + QString("Using resampler. From: %1 to %2")
+            .arg(settings.samplerate).arg(audio_samplerate));
+        src_ctx = src_new(2-src_quality, source_audio_channels, &error);
+        if (error)
+        {
+            Error(QString("Error creating resampler, the error was: %1")
+                  .arg(src_strerror(error)) );
+	    src_ctx = NULL;
+            return;
+        }
+        src_data.src_ratio = (double) audio_samplerate / settings.samplerate;
+        src_data.data_in = src_in;
+        src_data.data_out = src_out;
+        src_data.output_frames = 16384*6;
+        need_resampler = true;
+    }
+    
+    // Encode to AC-3 if not passing thru , there's > 2 channels
+    // and a passthru device is defined
+    if (!audio_passthru && allow_ac3_passthru &&
+        (audio_channels > 2 || audio_reenc))
+    {
+        VERBOSE(VB_AUDIO, LOC + "Creating AC-3 Encoder");
+        encoder = new AudioOutputDigitalEncoder();
+        if (!encoder->Init(CODEC_ID_AC3, 448000, audio_samplerate, audio_channels))
+        {
+            VERBOSE(VB_AUDIO, LOC + "Can't create AC-3 encoder");
+            delete encoder;
+            encoder = NULL;
+        }
+
+        audio_enc = true;
+    }
+
+    if(audio_passthru || audio_enc)
+        // AC-3 output - soundcard expects a 2ch 48k stream
+	audio_channels = 2;
+
+    audio_bytes_per_sample = audio_channels * audio_bits / 8;
+    source_audio_bytes_per_sample = source_audio_channels * audio_bits / 8;
+
+    VERBOSE(VB_GENERAL, QString("Opening audio device '%1'. ch %2(%3) sr %4 (reenc %5)")
             .arg(audio_main_device).arg(audio_channels)
-            .arg(source_audio_channels).arg(audio_samplerate));
+            .arg(source_audio_channels).arg(audio_samplerate).arg(audio_reenc));
 
     // Actually do the device specific open call
     if (!OpenDevice())
@@ -290,17 +341,22 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
         return;
     }
 
+    // Only used for software volume
+    if (set_initial_vol && internal_vol) 
+        volume = gContext->GetNumSetting("PCMMixerVolume", 80);
+    {
+        QString controlLabel = gContext->GetSetting("MixerControl", "PCM");
+        controlLabel += "MixerVolume";
+        volume = gContext->GetNumSetting(controlLabel, 80);
+    }
+
     SyncVolume();
     VolumeBase::UpdateVolume();
 
     VERBOSE(VB_AUDIO, LOC + QString("Audio fragment size: %1")
             .arg(fragment_size));
 
-    if (audio_buffer_unused < 0)
-        audio_buffer_unused = 0;
-
-    if (!gContext->GetNumSetting("AggressiveSoundcardBuffer", 0))
-        audio_buffer_unused = 0;
+    audio_buffer_unused = 0;
 
     audbuf_timecode = 0;
     audiotime = 0;
@@ -310,27 +366,6 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
     current_seconds = -1;
     source_bitrate = -1;
 
-    // NOTE: this won't do anything as above samplerate vars are set equal
-    // Check if we need the resampler
-    if (audio_samplerate != settings.samplerate)
-    {
-        int error;
-        VERBOSE(VB_GENERAL, LOC + QString("Using resampler. From: %1 to %2")
-                               .arg(settings.samplerate).arg(audio_samplerate));
-        src_ctx = src_new (SRC_SINC_BEST_QUALITY, audio_channels, &error);
-        if (error)
-        {
-            Error(QString("Error creating resampler, the error was: %1")
-                  .arg(src_strerror(error)) );
-            return;
-        }
-        src_data.src_ratio = (double) audio_samplerate / settings.samplerate;
-        src_data.data_in = src_in;
-        src_data.data_out = src_out;
-        src_data.output_frames = 16384*6;
-        need_resampler = true;
-    }
-
     if (needs_upmix)
     {
         VERBOSE(VB_AUDIO, LOC + QString("create upmixer"));
@@ -345,63 +380,15 @@ void AudioOutputBase::Reconfigure(const AudioSettings &orig_settings)
             (FreeSurround::SurroundMode)surround_mode);
 
         VERBOSE(VB_AUDIO, LOC +
-                QString("create upmixer done with surround mode %1")
+                QString("Create upmixer done with surround mode %1")
                 .arg(surround_mode));
     }
 
     VERBOSE(VB_AUDIO, LOC + QString("Audio Stretch Factor: %1")
             .arg(audio_stretchfactor));
-    VERBOSE(VB_AUDIO, QString("Audio Codec Used: %1")
-            .arg((audio_codec) ?
-                 codec_id_string(audio_codec->codec_id) : "not set"));
-
-    if (redo_stretch)
-    {
-        delete pSoundStretch;
-        pSoundStretch = NULL;
-        SetStretchFactorLocked(audio_stretchfactor);
-    }
-    else
-    {
-        SetStretchFactorLocked(audio_stretchfactor);
-        if (pSoundStretch)
-        {
-            // if its passthru then we need to reencode
-            if (audio_codec)
-            {
-                if (!encoder)
-                {
-                    VERBOSE(VB_AUDIO, LOC +
-                            QString("Creating Encoder for codec %1")
-                            .arg(audio_codec->codec_id));
-
-                    encoder = new AudioOutputDigitalEncoder();
-                    if (!encoder->Init(audio_codec->codec_id,
-                                audio_codec->bit_rate,
-                                audio_codec->sample_rate,
-                                audio_codec->channels
-                                ))
-                    {
-                        // eeks
-                        delete encoder;
-                        encoder = NULL;
-                        VERBOSE(VB_AUDIO, LOC + "Failed to Create Encoder");
-                    }
-                }
-            }
-            if (audio_codec && encoder)
-            {
-                pSoundStretch->setSampleRate(audio_codec->sample_rate);
-                pSoundStretch->setChannels(audio_codec->channels);
-            }
-            else
-            {
-                pSoundStretch->setSampleRate(audio_samplerate);
-                pSoundStretch->setChannels(audio_channels);
-            }
-        }
-    }
 
+    SetStretchFactorLocked(old_audio_stretchfactor);
+    
     // Setup visualisations, zero the visualisations buffers
     prepareVisuals();
 
@@ -437,10 +424,15 @@ void AudioOutputBase::KillAudio()
     VERBOSE(VB_AUDIO, LOC + "Killing AudioOutputDSP");
     killaudio = true;
     StopOutputThread();
+    QMutexLocker lock1(&audio_buflock);
 
     // Close resampler?
     if (src_ctx)
+    {
         src_delete(src_ctx);
+        src_ctx = NULL;
+    }
+
     need_resampler = false;
 
     // close sound stretcher
@@ -448,6 +440,8 @@ void AudioOutputBase::KillAudio()
     {
         delete pSoundStretch;
         pSoundStretch = NULL;
+        old_audio_stretchfactor = audio_stretchfactor;
+        audio_stretchfactor = 1.0;
     }
 
     if (encoder)
@@ -462,6 +456,7 @@ void AudioOutputBase::KillAudio()
         upmixer = NULL;
     }
     needs_upmix = false;
+    audio_enc = false;
 
     CloseDevice();
 
@@ -612,20 +607,14 @@ void AudioOutputBase::SetAudiotime(void)
 
     // include algorithmic latencies
     if (pSoundStretch)
-    {
-        // add the effect of any unused but processed samples,
-        // AC3 reencode does this
-        totalbuffer += (int)(pSoundStretch->numSamples() *
-                             audio_bytes_per_sample);
-        // add the effect of unprocessed samples in time stretch algo
         totalbuffer += (int)((pSoundStretch->numUnprocessedSamples() *
                               audio_bytes_per_sample) / audio_stretchfactor);
-    }
 
     if (upmixer && needs_upmix)
-    {
         totalbuffer += upmixer->sampleLatency() * audio_bytes_per_sample;
-    }
+
+    if (encoder) 
+         totalbuffer += encoder->Buffered();
 
     audiotime = audbuf_timecode - (int)(totalbuffer * 100000.0 /
                                    (audio_bytes_per_sample * effdspstretched));
@@ -651,6 +640,63 @@ int AudioOutputBase::GetAudioBufferedTime(void)
      return audbuf_timecode - GetAudiotime();
 }
 
+void AudioOutputBase::SetSWVolume(int new_volume, bool save)
+{
+    volume = new_volume;
+    if (save)
+    {
+        QString controlLabel = gContext->GetSetting("MixerControl", "PCM");
+        controlLabel += "MixerVolume";
+        gContext->SaveSetting(controlLabel, volume);
+    }
+}
+
+int AudioOutputBase::GetSWVolume()
+{
+    return volume;
+}
+
+template <class AudioDataType>
+void AudioOutputBase::_AdjustVolume(AudioDataType *buffer, int len, bool music)
+{
+    float g = volume / 100.0;
+
+    // Should probably be exponential - this'll do
+    g *= g;
+    
+    // Add gain to AC-3 - try to ~ match PCM volume
+    if (audio_enc && audio_reenc)
+        g *= 1.8;
+
+    // Music is relatively loud - ditto
+    else if (music)
+        g *= 0.4;
+
+    if (g == 1.0)
+        return;
+
+    for (int i = 0; i < (int)(len / sizeof(AudioDataType)); i++)
+    {
+        float s = static_cast<float>(buffer[i]) * g /
+                  static_cast<float>(numeric_limits<AudioDataType>::max());
+        if (s >= 1.0)
+            buffer[i] = numeric_limits<AudioDataType>::max();
+        else if (s <= -1.0)
+            buffer[i] = numeric_limits<AudioDataType>::min();
+        else
+            buffer[i] = static_cast<AudioDataType>
+                        (s * numeric_limits<AudioDataType>::max());
+    }
+}
+
+void AudioOutputBase::AdjustVolume(void *buffer, int len, bool music)
+{
+    if (audio_bits == 8)
+        _AdjustVolume<char>((char *)buffer, len, music);
+    else if (audio_bits == 16)
+        _AdjustVolume<short>((short *)buffer, len, music);
+}
+
 bool AudioOutputBase::AddSamples(char *buffers[], int samples,
                                  long long timecode)
 {
@@ -682,6 +728,8 @@ bool AudioOutputBase::AddSamples(char *buffers[], int samples,
         return false; // would overflow
     }
 
+    QMutexLocker lock1(&audio_buflock);
+
     // resample input if necessary
     if (need_resampler && src_ctx)
     {
@@ -726,6 +774,10 @@ bool AudioOutputBase::AddSamples(char *buffer, int samples, long long timecode)
     int abps = (encoder) ?
         encoder->audio_bytes_per_sample : audio_bytes_per_sample;
     int len = samples * abps;
+    
+    // Give original samples to mythmusic visualisation
+    dispatchVisual((unsigned char *)buffer, len, timecode,
+                   source_audio_channels, audio_bits);
 
     // Check we have enough space to write the data
     if (need_resampler && src_ctx)
@@ -750,6 +802,8 @@ bool AudioOutputBase::AddSamples(char *buffer, int samples, long long timecode)
         return false; // would overflow
     }
 
+    QMutexLocker lock1(&audio_buflock);
+
     // resample input if necessary
     if (need_resampler && src_ctx)
     {
@@ -810,9 +864,12 @@ int AudioOutputBase::WaitForFreeSpace(int samples)
             {
                 int error = src_reset(src_ctx);
                 if (error)
+                {
                     VERBOSE(VB_IMPORTANT, LOC_ERR + QString(
                             "Error occured while resetting resampler: %1")
                             .arg(src_strerror(error)));
+                    src_ctx = NULL;
+                }
             }
         }
     }
@@ -822,8 +879,6 @@ int AudioOutputBase::WaitForFreeSpace(int samples)
 void AudioOutputBase::_AddSamples(void *buffer, bool interleaved, int samples,
                                   long long timecode)
 {
-    audio_buflock.lock();
-
     int len; // = samples * audio_bytes_per_sample;
     int audio_bytes = audio_bits / 8;
     int org_waud = waud;
@@ -840,17 +895,17 @@ void AudioOutputBase::_AddSamples(void *buffer, bool interleaved, int samples,
             .arg(samples * abps)
             .arg(kAudioRingBufferSize-afree).arg(afree).arg(timecode)
             .arg(needs_upmix));
-
+    
+    len = WaitForFreeSpace(samples);
+        
     if (upmixer && needs_upmix)
     {
         int out_samples = 0;
+        org_waud = waud;
         int step = (interleaved)?source_audio_channels:1;
-        len = WaitForFreeSpace(samples);    // test
+	
         for (int itemp = 0; itemp < samples; )
         {
-            // just in case it does a processing cycle, release the lock
-            // to allow the output loop to do output
-            audio_buflock.unlock();
             if (audio_bytes == 2)
             {
                 itemp += upmixer->putSamples(
@@ -867,7 +922,6 @@ void AudioOutputBase::_AddSamples(void *buffer, bool interleaved, int samples,
                     source_audio_channels,
                     (interleaved) ? 0 : samples);
             }
-            audio_buflock.lock();
 
             int copy_samples = upmixer->numSamples();
             if (copy_samples)
@@ -901,8 +955,6 @@ void AudioOutputBase::_AddSamples(void *buffer, bool interleaved, int samples,
     }
     else
     {
-        len = WaitForFreeSpace(samples);
-
         if (interleaved)
         {
             char *mybuf = (char*)buffer;
@@ -937,138 +989,113 @@ void AudioOutputBase::_AddSamples(void *buffer, bool interleaved, int samples,
         }
     }
 
-    if (samples > 0)
+    if (samples <= 0)
+        return;
+        
+    if (pSoundStretch)
     {
-        if (pSoundStretch)
+        // does not change the timecode, only the number of samples
+        // back to orig pos
+        org_waud = waud;
+        int bdiff = kAudioRingBufferSize - org_waud;
+        int nSamplesToEnd = bdiff/abps;
+        if (bdiff < len)
         {
+            pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
+                                      (audiobuffer +
+                                       org_waud), nSamplesToEnd);
+            pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)audiobuffer,
+                                      (len - bdiff) / abps);
+        }
+        else
+        {
+            pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
+                                      (audiobuffer + org_waud),
+                                      len / abps);
+        }
 
-            // does not change the timecode, only the number of samples
-            // back to orig pos
-            org_waud = waud;
-            int bdiff = kAudioRingBufferSize - org_waud;
-            int nSamplesToEnd = bdiff/abps;
-            if (bdiff < len)
-            {
-                pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
-                                          (audiobuffer +
-                                           org_waud), nSamplesToEnd);
-                pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)audiobuffer,
-                                          (len - bdiff) / abps);
+        int nSamples = pSoundStretch->numSamples();
+        len = WaitForFreeSpace(nSamples); 
+        
+        while ((nSamples = pSoundStretch->numSamples())) 
+        {
+            if (nSamples > nSamplesToEnd) 
+                nSamples = nSamplesToEnd;
+            
+            nSamples = pSoundStretch->receiveSamples(
+                (soundtouch::SAMPLETYPE*)
+                (audiobuffer + org_waud), nSamples
+            );
+            
+            if (nSamples == nSamplesToEnd) {
+                org_waud = 0;
+                nSamplesToEnd = kAudioRingBufferSize/abps;
             }
-            else
-            {
-                pSoundStretch->putSamples((soundtouch::SAMPLETYPE*)
-                                          (audiobuffer + org_waud),
-                                          len / abps);
+            else {
+                org_waud += nSamples * abps;
+                nSamplesToEnd -= nSamples;
             }
+        }
+    }
 
-            if (encoder)
-            {
-                // pull out a packet's worth and reencode it until we
-                // don't have enough for any more packets
-                soundtouch::SAMPLETYPE *temp_buff =
-                    (soundtouch::SAMPLETYPE*)encoder->GetFrameBuffer();
-                size_t frameSize = encoder->FrameSize()/abps;
+    if (internal_vol && SWVolume())
+    {
+        int bdiff = kAudioRingBufferSize - waud;
+        bool music = (timecode < 1);
 
-                VERBOSE(VB_AUDIO+VB_TIMESTAMP,
-                        QString("_AddSamples Enc sfs=%1 bfs=%2 sss=%3")
-                        .arg(frameSize)
-                        .arg(encoder->FrameSize())
-                        .arg(pSoundStretch->numSamples()));
-
-                // process the same number of samples as it creates
-                // a full encoded buffer just like before
-                while (pSoundStretch->numSamples() >= frameSize)
-                {
-                    int got = pSoundStretch->receiveSamples(
-                        temp_buff, frameSize);
-                    int amount = encoder->Encode(temp_buff);
-
-                    VERBOSE(VB_AUDIO+VB_TIMESTAMP,
-                            QString("_AddSamples Enc bytes=%1 got=%2 left=%3")
-                            .arg(amount)
-                            .arg(got)
-                            .arg(pSoundStretch->numSamples()));
-
-                    if (!amount)
-                        continue;
-
-                    //len = WaitForFreeSpace(amount);
-                    char *ob = encoder->GetOutBuff();
-                    if (amount >= bdiff)
-                    {
-                        memcpy(audiobuffer + org_waud, ob, bdiff);
-                        ob += bdiff;
-                        amount -= bdiff;
-                        org_waud = 0;
-                    }
-                    if (amount > 0)
-                        memcpy(audiobuffer + org_waud, ob, amount);
-
-                    bdiff = kAudioRingBufferSize - amount;
-                    org_waud = (org_waud + amount) % kAudioRingBufferSize;
-                }
-            }
-            else
-            {
-                int newLen = 0;
-                int nSamples;
-                len = WaitForFreeSpace(pSoundStretch->numSamples() *
-                                       audio_bytes_per_sample);
-                do
-                {
-                    int samplesToGet = len/audio_bytes_per_sample;
-                    if (samplesToGet > nSamplesToEnd)
-                    {
-                        samplesToGet = nSamplesToEnd;
-                    }
-
-                    nSamples = pSoundStretch->receiveSamples(
-                        (soundtouch::SAMPLETYPE*)
-                        (audiobuffer + org_waud), samplesToGet);
-                    if (nSamples == nSamplesToEnd)
-                    {
-                        org_waud = 0;
-                        nSamplesToEnd = kAudioRingBufferSize/audio_bytes_per_sample;
-                    }
-                    else
-                    {
-                        int bufsz = nSamples * audio_bytes_per_sample;
-                        org_waud = (org_waud + bufsz) % kAudioRingBufferSize;
-                        nSamplesToEnd -= nSamples;
-                    }
-
-                    newLen += nSamples * audio_bytes_per_sample;
-                    len -= nSamples * audio_bytes_per_sample;
-                } while (nSamples > 0);
-            }
+        if (bdiff < len)
+        {
+            AdjustVolume(audiobuffer + waud, bdiff, music);
+            AdjustVolume(audiobuffer, len - bdiff, music);
         }
+        else
+            AdjustVolume(audiobuffer + waud, len, music);
+    }
 
-        waud = org_waud;
-        lastaudiolen = audiolen(false);
+    // Encode to AC-3? 
+    if (encoder) 
+    {
+        org_waud = waud;
+        int bdiff = kAudioRingBufferSize - org_waud;
+        int to_get = 0;
 
-        if (timecode < 0)
+        if (bdiff < len) 
         {
-            // mythmusic doesn't give timestamps..
-            timecode = (int)((samples_buffered * 100000.0) / effdsp);
+            encoder->Encode(audiobuffer + org_waud, bdiff);
+            to_get = encoder->Encode(audiobuffer, len - bdiff);
         }
- 
-        samples_buffered += samples;
- 
-        /* we want the time at the end -- but the file format stores
-           time at the start of the chunk. */
-        // even with timestretch, timecode is still calculated from original
-        // sample count
-        audbuf_timecode = timecode + (int)((samples * 100000.0) / effdsp);
+        else 
+            to_get = encoder->Encode(audiobuffer + org_waud, len);
 
-        if (interleaved)
+        if (to_get > 0) 
         {
-            dispatchVisual((unsigned char *)buffer, len, timecode,
-                           source_audio_channels, audio_bits);
+            if (to_get >= bdiff)
+            {
+                encoder->GetFrames(audiobuffer + org_waud, bdiff);
+                to_get -= bdiff;
+                org_waud = 0;
+            }
+            if (to_get > 0)
+                encoder->GetFrames(audiobuffer + org_waud, to_get);
+
+            org_waud += to_get;
         }
     }
 
-    audio_buflock.unlock();
+    waud = org_waud;
+    lastaudiolen = audiolen(false);
+
+    if (timecode < 0)
+        // mythmusic doesn't give timestamps..
+        timecode = (int)((samples_buffered * 100000.0) / effdsp);
+
+    samples_buffered += samples;
+
+    /* we want the time at the end -- but the file format stores
+       time at the start of the chunk. */
+    // even with timestretch, timecode is still calculated from original
+    // sample count
+    audbuf_timecode = timecode + (int)((samples * 100000.0) / effdsp);
 }
 
 void AudioOutputBase::Status()
@@ -1209,18 +1236,9 @@ void AudioOutputBase::OutputAudioLoop(void)
                 last_space_on_soundcard = space_on_soundcard;
             }
 
-            numlowbuffer++;
-            if (numlowbuffer > 5 && audio_buffer_unused)
-            {
-                VERBOSE(VB_IMPORTANT, LOC + "dropping back audio_buffer_unused");
-                audio_buffer_unused /= 2;
-            }
-
             usleep(5000);
             continue;
         }
-        else
-            numlowbuffer = 0;
 
         Status();
 
diff --git a/mythtv/libs/libmyth/audiooutputbase.h b/mythtv/libs/libmyth/audiooutputbase.h
index 1f636e2..46ebc0a 100644
--- a/mythtv/libs/libmyth/audiooutputbase.h
+++ b/mythtv/libs/libmyth/audiooutputbase.h
@@ -43,9 +43,13 @@ class AudioOutputBase : public AudioOutput, public QThread
 
     virtual void SetStretchFactor(float factor);
     virtual float GetStretchFactor(void) const;
+    virtual bool ToggleUpmix(void);
 
     virtual void Reset(void);
 
+    void SetSWVolume(int new_volume, bool save);
+    int GetSWVolume(void);
+
     // timecode is in milliseconds.
     virtual bool AddSamples(char *buffer, int samples, long long timecode);
     virtual bool AddSamples(char *buffers[], int samples, long long timecode);
@@ -85,6 +89,8 @@ class AudioOutputBase : public AudioOutput, public QThread
     virtual void WriteAudio(unsigned char *aubuf, int size) = 0;
     virtual int  GetSpaceOnSoundcard(void) const = 0;
     virtual int  GetBufferedOnSoundcard(void) const = 0;
+    virtual vector<int> GetSupportedRates(void) 
+        { vector<int> rates; return rates; }
     /// You need to call this from any implementation in the dtor.
     void KillAudio(void);
 
@@ -122,6 +128,7 @@ class AudioOutputBase : public AudioOutput, public QThread
 
     // Basic details about the audio stream
     int audio_channels;
+    int audio_codec;
     int audio_bytes_per_sample;
     int audio_bits;
     int audio_samplerate;
@@ -132,9 +139,10 @@ class AudioOutputBase : public AudioOutput, public QThread
     QString audio_passthru_device;
 
     bool audio_passthru;
+    bool audio_enc;
+    bool audio_reenc;
 
     float audio_stretchfactor;
-    AVCodecContext *audio_codec;
     AudioOutputSource source;
 
     bool killaudio;
@@ -144,8 +152,15 @@ class AudioOutputBase : public AudioOutput, public QThread
     bool buffer_output_data_for_use; //  used by AudioOutputNULL
 
     int configured_audio_channels;
+    int orig_config_channels;
+    int src_quality;
 
  private:
+    // software volume
+    template <class AudioDataType>
+    void _AdjustVolume(AudioDataType *buffer, int len, bool music);
+    void AdjustVolume(void *buffer, int len, bool music);
+
     // resampler
     bool need_resampler;
     SRC_STATE *src_ctx;
@@ -156,9 +171,13 @@ class AudioOutputBase : public AudioOutput, public QThread
     FreeSurround              *upmixer;
 
     int source_audio_channels;
+    int source_audio_samplerate;
     int source_audio_bytes_per_sample;
     bool needs_upmix;
     int surround_mode;
+    bool allow_ac3_passthru;
+    float old_audio_stretchfactor;
+    int volume;
 
     bool blocking; // do AddSamples calls block?
 
diff --git a/mythtv/libs/libmyth/audiooutputdigitalencoder.cpp b/mythtv/libs/libmyth/audiooutputdigitalencoder.cpp
index a9688c9..47b0fa7 100644
--- a/mythtv/libs/libmyth/audiooutputdigitalencoder.cpp
+++ b/mythtv/libs/libmyth/audiooutputdigitalencoder.cpp
@@ -32,9 +32,8 @@ extern "C" {
 AudioOutputDigitalEncoder::AudioOutputDigitalEncoder(void) :
     audio_bytes_per_sample(0),
     av_context(NULL),
-    outbuf(NULL),
-    outbuf_size(0),
-    frame_buffer(NULL),
+    outbuflen(0),
+    inbuflen(0),
     one_frame_bytes(0)
 {
 }
@@ -52,20 +51,6 @@ void AudioOutputDigitalEncoder::Dispose()
         av_free(av_context);
         av_context = NULL;
     }
-
-    if (outbuf)
-    {
-        delete [] outbuf;
-        outbuf = NULL;
-        outbuf_size = 0;
-    }
-
-    if (frame_buffer)
-    {
-        delete [] frame_buffer;
-        frame_buffer = NULL;
-        one_frame_bytes = 0;
-    }
 }
 
 //CODEC_ID_AC3
@@ -81,7 +66,9 @@ bool AudioOutputDigitalEncoder::Init(
             .arg(samplerate)
             .arg(channels));
 
-    //codec = avcodec_find_encoder(codec_id);
+    // We need to do this when called from mythmusic
+    avcodec_init();
+    avcodec_register_all();
     // always AC3 as there is no DTS encoder at the moment 2005/1/9
     codec = avcodec_find_encoder(CODEC_ID_AC3);
     if (!codec)
@@ -110,8 +97,6 @@ bool AudioOutputDigitalEncoder::Init(
     audio_bytes_per_sample = bytes_per_frame;
     one_frame_bytes = bytes_per_frame * av_context->frame_size;
 
-    outbuf_size = 16384;    // ok for AC3 but DTS?
-    outbuf = new char [outbuf_size];
     VERBOSE(VB_AUDIO, QString("DigitalEncoder::Init fs=%1, bpf=%2 ofb=%3")
             .arg(av_context->frame_size)
             .arg(bytes_per_frame)
@@ -259,10 +244,9 @@ typedef struct {
 static int encode_frame(
         bool dts, 
         unsigned char *data,
-        size_t &len)
+        size_t enc_len)
 {
     unsigned char *payload = data + 8;  // skip header, currently 52 or 54bits
-    size_t         enc_len;
     int            flags, sample_rate, bit_rate;
 
     // we don't do any length/crc validation of the AC3 frame here; presumably
@@ -273,7 +257,8 @@ static int encode_frame(
     // ignore, and if so, may as well just assume that it will ignore
     // anything with a bad CRC...
 
-    uint nr_samples = 0, block_len;
+    uint nr_samples = 0, block_len = 0;
+
     if (dts)
     {
         enc_len = dts_syncinfo(payload, &flags, &sample_rate, &bit_rate);
@@ -302,13 +287,6 @@ static int encode_frame(
         }
     }
 
-    if (enc_len == 0 || enc_len > len)
-    {
-        int l = len;
-        len = 0;
-        return l;
-    }
-
     enc_len = std::min((uint)enc_len, block_len - 8);
 
     //uint32_t x = *(uint32_t*)payload;
@@ -361,31 +339,42 @@ static int encode_frame(
     data[6] = (enc_len << 3) & 0xFF;
     data[7] = (enc_len >> 5) & 0xFF;
     memset(payload + enc_len, 0, block_len - 8 - enc_len);
-    len = block_len;
 
     return enc_len;
 }
 
-// must have exactly 1 frames worth of data
-size_t AudioOutputDigitalEncoder::Encode(short *buff)
+size_t AudioOutputDigitalEncoder::Encode(void *buf, int len)
 {
-    int encsize = 0;
     size_t outsize = 0;
- 
-    // put data in the correct spot for encode frame
-    outsize = avcodec_encode_audio(
-        av_context, ((uchar*)outbuf) + 8, outbuf_size - 8, buff);
 
-    size_t tmpsize = outsize;
+    int fs = FrameSize();
+    memcpy(inbuf+inbuflen, buf, len);
+    inbuflen += len;
+    int frames = inbuflen / fs;
 
-    outsize = MAX_AC3_FRAME_SIZE;
-    encsize = encode_frame(
-        /*av_context->codec_id==CODEC_ID_DTS*/ false,
-        (unsigned char*)outbuf, outsize);
+    while (frames--) 
+    {
+        // put data in the correct spot for encode frame
+        outsize = avcodec_encode_audio(
+            av_context, ((uchar*)outbuf) + outbuflen + 8, OUTBUFSIZE - 8, (short int *)inbuf);
+
+        encode_frame(
+            /*av_context->codec_id==CODEC_ID_DTS*/ false,
+            (unsigned char*)outbuf + outbuflen, outsize
+        );
+
+        outbuflen += MAX_AC3_FRAME_SIZE;
+        inbuflen -= fs;
+        memmove(inbuf, inbuf+fs, inbuflen);
+    }
 
-    VERBOSE(VB_AUDIO+VB_TIMESTAMP, 
-            QString("DigitalEncoder::Encode len1=%1 len2=%2 finallen=%3")
-                .arg(tmpsize).arg(encsize).arg(outsize));
+    return outbuflen;
+}
 
-    return outsize;
+void AudioOutputDigitalEncoder::GetFrames(void *ptr, int maxlen)
+{
+    int len = (maxlen < outbuflen ? maxlen : outbuflen);
+    memcpy(ptr, outbuf, len);
+    outbuflen -= len;
+    memmove(outbuf, outbuf+len, outbuflen);
 }
diff --git a/mythtv/libs/libmyth/audiooutputdigitalencoder.h b/mythtv/libs/libmyth/audiooutputdigitalencoder.h
index 8a4689a..8d81298 100644
--- a/mythtv/libs/libmyth/audiooutputdigitalencoder.h
+++ b/mythtv/libs/libmyth/audiooutputdigitalencoder.h
@@ -5,6 +5,9 @@ extern "C" {
 #include "libavcodec/avcodec.h"
 };
 
+#define INBUFSIZE 131072
+#define OUTBUFSIZE 98304
+
 class AudioOutputDigitalEncoder
 {
   public:
@@ -13,29 +16,21 @@ class AudioOutputDigitalEncoder
 
     bool   Init(CodecID codec_id, int bitrate, int samplerate, int channels);
     void   Dispose(void);
-    size_t Encode(short * buff);
-
-    inline char *GetFrameBuffer(void);
+    size_t Encode(void *buf, int len);
+    void   GetFrames(void *ptr, int maxlen);
     size_t FrameSize(void)  const { return one_frame_bytes; }
-    char  *GetOutBuff(void) const { return outbuf;          }
+    int    Buffered(void) const { return inbuflen; }
 
   public:
     size_t audio_bytes_per_sample;
 
   private:
     AVCodecContext *av_context;
-    char           *outbuf;
-    int             outbuf_size;
-    char           *frame_buffer;
+    char            outbuf[OUTBUFSIZE];
+    char            inbuf[INBUFSIZE];
+    int             outbuflen;
+    int             inbuflen;
     size_t          one_frame_bytes;
 };
 
-inline char *AudioOutputDigitalEncoder::GetFrameBuffer(void)
-{
-    if (!frame_buffer && av_context)
-        frame_buffer = new char [one_frame_bytes];
-
-    return frame_buffer; 
-}
-
 #endif
diff --git a/mythtv/libs/libmyth/audiooutputjack.cpp b/mythtv/libs/libmyth/audiooutputjack.cpp
index 7e0ad0d..f7aefa0 100644
--- a/mythtv/libs/libmyth/audiooutputjack.cpp
+++ b/mythtv/libs/libmyth/audiooutputjack.cpp
@@ -30,6 +30,44 @@ AudioOutputJACK::AudioOutputJACK(const AudioSettings &settings) :
     Reconfigure(settings);
 }
 
+vector<int> AudioOutputJACK::GetSupportedRates()
+{
+    const int srates[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
+    vector<int> rates(srates, srates + sizeof(srates) / sizeof(int) );
+    unsigned long jack_port_flags = 0;
+    unsigned int jack_port_name_count = 1;
+    const char *jack_port_name = audio_main_device.toAscii();
+    int err = -1;
+    audioid = -1;
+    vector<int>::iterator it = rates.begin();
+
+    while (it != rates.end())
+    {
+        unsigned long lrate = (unsigned long) *it;
+        err = JACK_OpenEx(&audioid, 16, &lrate,
+                          2, 2, &jack_port_name, jack_port_name_count,
+                          jack_port_flags);
+
+        if (err == ERR_OPENING_JACK)
+        {
+            Error(QString("Error connecting to jackd: %1. Is it running?")
+                  .arg(audio_main_device));
+            rates.clear();
+            return rates;
+        }
+        else
+            if (err == ERR_RATE_MISMATCH)
+                it = rates.erase(it);
+            else
+                it++;
+
+        JACK_Close(audioid);
+        audioid = -1;
+    }
+    return rates;
+}
+
+
 AudioOutputJACK::~AudioOutputJACK()
 {
     // Close down all audio stuff
diff --git a/mythtv/libs/libmyth/audiooutputjack.h b/mythtv/libs/libmyth/audiooutputjack.h
index f87538e..161a346 100644
--- a/mythtv/libs/libmyth/audiooutputjack.h
+++ b/mythtv/libs/libmyth/audiooutputjack.h
@@ -23,6 +23,7 @@ class AudioOutputJACK : public AudioOutputBase
     virtual void WriteAudio(unsigned char *aubuf, int size);
     virtual int  GetSpaceOnSoundcard(void) const;
     virtual int  GetBufferedOnSoundcard(void) const;
+    vector<int> GetSupportedRates(void); 
 
   private:
 
diff --git a/mythtv/libs/libmyth/audiooutputoss.cpp b/mythtv/libs/libmyth/audiooutputoss.cpp
index 127bf6e..9bd4db1 100644
--- a/mythtv/libs/libmyth/audiooutputoss.cpp
+++ b/mythtv/libs/libmyth/audiooutputoss.cpp
@@ -42,6 +42,36 @@ AudioOutputOSS::~AudioOutputOSS()
     KillAudio();
 }
 
+vector<int> AudioOutputOSS::GetSupportedRates()
+{
+    const int srates[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
+    vector<int> rates(srates, srates + sizeof(srates) / sizeof(int) );
+    audiofd = open(audio_main_device.toAscii(), O_WRONLY | O_NONBLOCK);
+
+    if (audiofd < 0)
+    {
+        VERBOSE(VB_IMPORTANT, QString("Error opening audio device (%1), the"
+                " error was: %2").arg(audio_main_device).arg(strerror(errno)));
+        rates.clear();
+        return rates;
+    }
+
+    vector<int>::iterator it = rates.begin();
+
+    while (it != rates.end())
+    {
+        if(ioctl(audiofd, SNDCTL_DSP_SPEED, &audio_samplerate) < 0)
+            it = rates.erase(it);
+        else
+            it++;
+    }
+
+    close(audiofd);
+    audiofd = -1;
+
+    return rates;
+}
+
 bool AudioOutputOSS::OpenDevice()
 {
     numbadioctls = 0;
@@ -287,6 +317,9 @@ void AudioOutputOSS::VolumeInit()
     int volume = 0;
 
     QString device = gContext->GetSetting("MixerDevice", "/dev/mixer");
+    if (device.toLower() == "software")
+        return;
+
     QByteArray dev = device.toAscii();
     mixerfd = open(dev.constData(), O_RDONLY);
 
diff --git a/mythtv/libs/libmyth/audiooutputoss.h b/mythtv/libs/libmyth/audiooutputoss.h
index d5105a2..a78e650 100644
--- a/mythtv/libs/libmyth/audiooutputoss.h
+++ b/mythtv/libs/libmyth/audiooutputoss.h
@@ -23,6 +23,7 @@ class AudioOutputOSS : public AudioOutputBase
     virtual void WriteAudio(unsigned char *aubuf, int size);
     virtual int  GetSpaceOnSoundcard(void) const;
     virtual int  GetBufferedOnSoundcard(void) const;
+    vector<int> GetSupportedRates(void);
 
   private:
     void VolumeInit(void);
diff --git a/mythtv/libs/libmyth/audiosettings.cpp b/mythtv/libs/libmyth/audiosettings.cpp
index 68e515b..fa24533 100644
--- a/mythtv/libs/libmyth/audiosettings.cpp
+++ b/mythtv/libs/libmyth/audiosettings.cpp
@@ -7,16 +7,18 @@
 
 #include "audiosettings.h"
 
+// startup_upmixer 
 AudioSettings::AudioSettings() :
     main_device(QString::null),
     passthru_device(QString::null),
     bits(-1),
     channels(-1),
+    codec(0),
     samplerate(-1),
     set_initial_vol(false),
     use_passthru(false),
-    codec(NULL),
-    source(AUDIOOUTPUT_UNKNOWN)
+    source(AUDIOOUTPUT_UNKNOWN),
+    upmixer(0)
 {
 }
 
@@ -25,11 +27,12 @@ AudioSettings::AudioSettings(const AudioSettings &other) :
     passthru_device(other.passthru_device),
     bits(other.bits),
     channels(other.channels),
+    codec(other.codec),
     samplerate(other.samplerate),
     set_initial_vol(other.set_initial_vol),
     use_passthru(other.use_passthru),
-    codec(other.codec),
-    source(other.source)
+    source(other.source),
+    upmixer(other.upmixer)
 {
 }
 
@@ -38,38 +41,42 @@ AudioSettings::AudioSettings(
     const QString &audio_passthru_device,
     int audio_bits,
     int audio_channels,
+    int audio_codec,
     int audio_samplerate,
     AudioOutputSource audio_source,
     bool audio_set_initial_vol,
     bool audio_use_passthru,
-    void *audio_codec) :
+    int upmixer_startup) :
     main_device(audio_main_device),
     passthru_device(audio_passthru_device),
     bits(audio_bits),
     channels(audio_channels),
+    codec(audio_codec),
     samplerate(audio_samplerate),
     set_initial_vol(audio_set_initial_vol),
     use_passthru(audio_use_passthru),
-    codec(audio_codec),
-    source(audio_source)
+    source(audio_source),
+    upmixer(upmixer_startup)
 {
 }
 
 AudioSettings::AudioSettings(
     int   audio_bits, 
     int   audio_channels, 
+    int   audio_codec,
     int   audio_samplerate,
     bool  audio_use_passthru,
-    void *audio_codec) :
+    int   upmixer_startup) :
     main_device(QString::null),
     passthru_device(QString::null),
     bits(audio_bits),
     channels(audio_channels),
+    codec(audio_codec),
     samplerate(audio_samplerate),
     set_initial_vol(false),
     use_passthru(audio_use_passthru),
-    codec(audio_codec),
-    source(AUDIOOUTPUT_UNKNOWN)
+    source(AUDIOOUTPUT_UNKNOWN),
+    upmixer(upmixer_startup)
 {
 }
 
diff --git a/mythtv/libs/libmyth/audiosettings.h b/mythtv/libs/libmyth/audiosettings.h
index f9349f4..364da76 100644
--- a/mythtv/libs/libmyth/audiosettings.h
+++ b/mythtv/libs/libmyth/audiosettings.h
@@ -29,17 +29,19 @@ class MPUBLIC AudioSettings
         const QString    &audio_passthru_device,
         int               audio_bits,
         int               audio_channels,
+        int               audio_codec,
         int               audio_samplerate,
         AudioOutputSource audio_source,
         bool              audio_set_initial_vol,
         bool              audio_use_passthru,
-        void             *audio_codec = NULL);
+        int               upmixer_startup = 0);
 
     AudioSettings(int   audio_bits, 
                   int   audio_channels, 
+                  int   audio_codec,
                   int   audio_samplerate,
                   bool  audio_use_passthru,
-                  void *audio_codec = NULL);
+                  int   upmixer_startup = 0);
 
     void FixPassThrough(void);
     void TrimDeviceType(void);
@@ -54,11 +56,12 @@ class MPUBLIC AudioSettings
   public:
     int     bits;
     int     channels;
+    int     codec;
     int     samplerate;
     bool    set_initial_vol;
     bool    use_passthru;
-    void   *codec;
     AudioOutputSource source;
+    int     upmixer;
 };
 
 #endif // _AUDIO_SETTINGS_H_
diff --git a/mythtv/libs/libmyth/volumebase.cpp b/mythtv/libs/libmyth/volumebase.cpp
index d1f1fb0..49514f9 100644
--- a/mythtv/libs/libmyth/volumebase.cpp
+++ b/mythtv/libs/libmyth/volumebase.cpp
@@ -10,6 +10,20 @@ VolumeBase::VolumeBase() :
     internal_vol(false), volume(80), 
     current_mute_state(kMuteOff)
 {
+    swvol = swvol_setting =
+        (gContext->GetSetting("MixerDevice", "default").toLower() == "software");
+}
+
+bool VolumeBase::SWVolume(void)
+{
+    return swvol;
+}
+
+void VolumeBase::SWVolume(bool set)
+{
+    if (swvol_setting)
+        return;
+    swvol = set;
 }
 
 uint VolumeBase::GetCurrentVolume(void) const
@@ -76,9 +90,17 @@ MuteState VolumeBase::NextMuteState(MuteState cur)
 void VolumeBase::UpdateVolume(void)
 {
     int new_volume = volume;
+    bool save = true;
     if (current_mute_state == kMuteAll)
     {
         new_volume = 0;
+        save = false;
+    }
+
+    if (swvol)
+    {
+        SetSWVolume(new_volume, save);
+        return;
     }
     
     // TODO: Avoid assumption that there are 2 channels!
@@ -102,6 +124,9 @@ void VolumeBase::UpdateVolume(void)
 void VolumeBase::SyncVolume(void)
 {
     // Read the volume from the audio driver and setup our internal state to match
-    volume = GetVolumeChannel(0);
+    if (swvol)
+        volume = GetSWVolume();
+    else
+        volume = GetVolumeChannel(0);
 }
 
diff --git a/mythtv/libs/libmyth/volumebase.h b/mythtv/libs/libmyth/volumebase.h
index 4257f0b..68fb6f1 100644
--- a/mythtv/libs/libmyth/volumebase.h
+++ b/mythtv/libs/libmyth/volumebase.h
@@ -20,6 +20,8 @@ class MPUBLIC VolumeBase
     VolumeBase();    
     virtual ~VolumeBase() {};
 
+    void SWVolume(bool set);
+    bool SWVolume(void);
     virtual uint GetCurrentVolume(void) const;
     virtual void SetCurrentVolume(int value);
     virtual void AdjustCurrentVolume(int change);
@@ -34,6 +36,8 @@ class MPUBLIC VolumeBase
 
     virtual int GetVolumeChannel(int channel) const = 0; // Returns 0-100
     virtual void SetVolumeChannel(int channel, int volume) = 0; // range 0-100 for vol
+    virtual void SetSWVolume(int new_volume, bool save) = 0;
+    virtual int GetSWVolume(void) = 0;
 
     void UpdateVolume(void);
     void SyncVolume(void);
@@ -44,6 +48,8 @@ class MPUBLIC VolumeBase
     
     int volume;
     MuteState current_mute_state;
+    bool swvol;
+    bool swvol_setting;
 
 };
 
diff --git a/mythtv/libs/libmythfreesurround/el_processor.cpp b/mythtv/libs/libmythfreesurround/el_processor.cpp
index 8b22b81..8aba98e 100644
--- a/mythtv/libs/libmythfreesurround/el_processor.cpp
+++ b/mythtv/libs/libmythfreesurround/el_processor.cpp
@@ -26,7 +26,6 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #include "fftw3.h"
 #else
 extern "C" {
-#include "libavutil/declare_aligned.h"
 #include "dsputil.h"
 };
 typedef FFTSample FFTComplexArray[2];
@@ -41,17 +40,7 @@ typedef std::complex<float> cfloat;
 
 const float PI = 3.141592654;
 const float epsilon = 0.000001;
-//const float center_level = 0.5*sqrt(0.5);   // gain of the center channel
-//const float center_level = sqrt(0.5);   // gain of the center channel
-const float center_level = 1.0;   // gain of the center channel
-//const float center_level = 0.5;   // gain of the center channel
-
-// should be .6-.7
-// but with centerlevel 2x what its supposed to be, we halve 0.68
-// to keep center from clipping
-//const float window_gain = 0.34;     
-//const float window_gain = 0.68;     
-const float window_gain = 0.95;     // to prive a bit of margin
+const float center_level = 0.5*sqrt(0.5);
 
 // private implementation of the surround decoder
 class decoder_impl {
@@ -99,19 +88,11 @@ public:
             outbuf[c].resize(N);
             filter[c].resize(N);
         }
-        // DC component of filters is always 0
-        for (unsigned c=0;c<5;c++)
-        {
-            filter[c][0] = 0.0;
-            filter[c][1] = 0.0;
-            filter[c][halfN] = 0.0;
-        }
         sample_rate(48000);
         // generate the window function (square root of hann, b/c it is applied before and after the transform)
         wnd.resize(N);
-        // dft normalization included in the window for zero cost scaling
-        // also add a gain factor of *2 due to processing gain in algo (see center_level)
-        surround_gain(1.0);
+        for (unsigned k=0;k<N;k++)
+            wnd[k] = sqrt(0.5*(1-cos(2*PI*k/N))/N);
         current_buf = 0;
         memset(inbufs, 0, sizeof(inbufs));
         memset(outbufs, 0, sizeof(outbufs));
@@ -195,10 +176,10 @@ public:
     // set lfe filter params
     void sample_rate(unsigned int srate) {
         // lfe filter is just straight through band limited
-        unsigned int cutoff = (250*N)/srate;
+        unsigned int cutoff = (30*N)/srate;
         for (unsigned f=0;f<=halfN;f++) {           
-            if ((f>=2) && (f<cutoff))
-                filter[5][f] = 1.0;
+            if (f<cutoff)
+                filter[5][f] = 0.5*sqrt(0.5);
             else
                 filter[5][f] = 0.0;
         }
@@ -217,12 +198,6 @@ public:
         E = (o+v)*n; F = (o+u)*n; G = (o-v)*n;  H = (o-u)*n;
     }
 
-    void surround_gain(float gain) {
-        master_gain = gain * window_gain * 0.5 * 0.25;
-        for (unsigned k=0;k<N;k++)
-            wnd[k] = sqrt(master_gain*(1-cos(2*PI*k/N))/N);
-    }
-
     // set the phase shifting mode
     void phase_mode(unsigned mode) {
         const float modes[4][2] = {{0,0},{0,PI},{PI,0},{-PI/2,PI/2}};
@@ -293,7 +268,7 @@ private:
 
         // 2. compare amplitude and phase of each DFT bin and produce the X/Y coordinates in the sound field
         //    but dont do DC or N/2 component
-        for (unsigned f=2;f<halfN;f++) {           
+        for (unsigned f=0;f<halfN;f++) {           
             // get left/right amplitudes/phases
             float ampL = amplitude(dftL[f]), ampR = amplitude(dftR[f]);
             float phaseL = phase(dftL[f]), phaseR = phase(dftR[f]);
@@ -308,41 +283,6 @@ private:
             phaseDiff = abs(phaseDiff);
 
             if (linear_steering) {
-/*              cfloat w = polar(sqrt(ampL*ampL+ampR*ampR), (phaseL+phaseR)/2);
-                cfloat lt = cfloat(dftL[f][0],dftL[f][1])/w, rt = cfloat(dftR[f][0],dftR[f][1])/w;              */
-//              xfs[f] = -(C*(rt-H) - B*E + F*A + G*(D-lt)) / (G*A - C*E).real();
-//              yfs[f] = (rt - (xfs[f]*E+H))/(F+xfs[f]*G);
-
-                /*
-                Problem: 
-                This assumes that the values are interpolated linearly between the cardinal points.
-                But this way we have no chance of knowing the average volume...
-                - Can we solve that computing everything under the assumption of normalized volume?
-                  No. Seemingly not.
-                - Maybe we should add w explitcitly into the equation and see if we can solve it...
-                */
-
-
-                //cfloat lt(0.5,0),rt(0.5,0);
-                //cfloat x(0,0), y(1,0);
-                /*cfloat p = (C*(rt-H) - B*E + F*A + G*(D-lt)) / (G*A - C*E);
-                cfloat q = B*(rt+H) + F*(D-lt) / (G*A - C*E);
-                cfloat s = sqrt(p*p/4.0f - q);
-                cfloat x = -p;
-                cfloat x1 = -p/2.0f + s;
-                cfloat x2 = -p/2.0f - s;
-                float x = 0;
-                if (x1.real() >= -1 && x1.real() <= 1)
-                    x = x1.real();
-                else if (x2.real() >= -1 && x2.real() <= 1)
-                    x = x2.real();*/
-
-                //cfloat yp = (rt - (x*E+H))/(F+x*G);
-                //cfloat xp = (lt - (y*B+D))/(A+y*C);
-
-                /*xfs[f] = x;
-                yfs[f] = y.real();*/
-
                 // --- this is the fancy new linear mode ---
 
                 // get sound field x/y position
@@ -600,7 +540,6 @@ private:
     float surround_high,surround_low;  // high and low surround mixing coefficient (e.g. 0.8165/0.5774)
     float surround_balance;            // the xfs balance that follows from the coeffs
     float surround_level;              // gain for the surround channels (follows from the coeffs
-    float master_gain;                 // gain for all channels
     float phase_offsetL, phase_offsetR;// phase shifts to be applied to the rear channels
     float front_separation;            // front stereo separation
     float rear_separation;             // rear stereo separation
@@ -628,8 +567,6 @@ void fsurround_decoder::flush() { impl->flush(); }
 
 void fsurround_decoder::surround_coefficients(float a, float b) { impl->surround_coefficients(a,b); }
 
-void fsurround_decoder::gain(float gain) { impl->surround_gain(gain); }
-
 void fsurround_decoder::phase_mode(unsigned mode) { impl->phase_mode(mode); }
 
 void fsurround_decoder::steering_mode(bool mode) { impl->steering_mode(mode); }
diff --git a/mythtv/libs/libmythfreesurround/el_processor.h b/mythtv/libs/libmythfreesurround/el_processor.h
index 021786a..461db53 100644
--- a/mythtv/libs/libmythfreesurround/el_processor.h
+++ b/mythtv/libs/libmythfreesurround/el_processor.h
@@ -47,14 +47,11 @@ public:
 	//  a is the coefficient of left rear in left total, b is the coefficient of left rear in right total; the same is true for right.
 	void surround_coefficients(float a, float b);
 
-	// override for master surround gain
-	void gain(float gain);
-
 	// set the phase shifting mode for decoding
-	// 0 = (+0,+0)   - music mode
-	// 1 = (+0,+180) - PowerDVD compatibility
-	// 2 = (+180,+0) - BeSweet compatibility
-	// 3 = (-90,+90) - This seems to work. I just don't know why.
+	// 0 = (+0,+0)   - music mode
+	// 1 = (+0,+180) - PowerDVD compatibility
+	// 2 = (+180,+0) - BeSweet compatibility
+	// 3 = (-90,+90) - This seems to work. I just don't know why.
 	void phase_mode(unsigned mode);
 
 	// override the steering mode
diff --git a/mythtv/libs/libmythfreesurround/freesurround.cpp b/mythtv/libs/libmythfreesurround/freesurround.cpp
index e0cf162..6da573d 100644
--- a/mythtv/libs/libmythfreesurround/freesurround.cpp
+++ b/mythtv/libs/libmythfreesurround/freesurround.cpp
@@ -63,10 +63,9 @@ using namespace std;
 const unsigned default_block_size = 8192;
 // there will be a slider for this in the future
 //const float master_gain = 1.0;
-//#define MASTER_GAIN * master_gain
+//#define MASTER_GAIN * master_gain 
 #define MASTER_GAIN
-//const float master_gain = 1.0/(1<<15);
-//const float inv_master_gain = (1<<15);
+//const float inv_master_gain = 1.0;
 //#define INV_MASTER_GAIN * inv_master_gain
 #define INV_MASTER_GAIN
 
@@ -192,15 +191,13 @@ FreeSurround::FreeSurround(uint srate, bool moviemode, SurroundMode smode) :
     if (moviemode)
     {
         params.phasemode = 1;
-        params.center_width = 0;
-        params.gain = 1.0;
+        params.center_width = 25;
+        params.dimension = 0.5;
     }
     else
     {
-        params.center_width = 70;
-        // for 50, gain should be about 1.9, c/lr about 2.7
-        // for 70, gain should be about 3.1, c/lr about 1.5
-        params.gain = 3.1;
+        params.center_width = 65;
+        params.dimension = 0.3;
     }
     switch (surround_mode)
     {
@@ -236,7 +233,6 @@ void FreeSurround::SetParams()
         decoder->phase_mode(params.phasemode);
         decoder->surround_coefficients(params.coeff_a, params.coeff_b);				
         decoder->separation(params.front_sep/100.0,params.rear_sep/100.0);
-        decoder->gain(params.gain);
     }
 }
 
@@ -250,8 +246,7 @@ FreeSurround::fsurround_params::fsurround_params(
     phasemode(0),
     steering(1),
     front_sep(100),
-    rear_sep(100), 
-    gain(1.0)
+    rear_sep(100) 
 {
 }
 
@@ -329,11 +324,11 @@ uint FreeSurround::putSamples(short* samples, uint numSamples, uint numChannels,
                     for (i=0;(i<numSamples) && (ic < bs);i++,ic++)
                     {
                         int16bufs->l[ic] = *samples++ >> 1;
-                        int16bufs->c[ic] = *samples++ >> 1;
                         int16bufs->r[ic] = *samples++ >> 1;
+                        int16bufs->c[ic] = *samples++ >> 1;
+                        int16bufs->lfe[ic] = *samples++ >> 1;
                         int16bufs->ls[ic] = *samples++ >> 1;
                         int16bufs->rs[ic] = *samples++ >> 1;
-                        int16bufs->lfe[ic] = *samples++ >> 1;
                     }
                     break;
             }
@@ -391,11 +386,11 @@ uint FreeSurround::putSamples(short* samples, uint numSamples, uint numChannels,
                         for (i=0;i<numSamples;i++)
                         {
                             *l++ = *samples++ >> 1;
-                            *c++ = *samples++ >> 1;
                             *r++ = *samples++ >> 1;
+                            *c++ = *samples++ >> 1;
+                            *lfe++ = *samples++ >> 1;
                             *ls++ = *samples++ >> 1;
                             *rs++ = *samples++ >> 1;
-                            *lfe++ = *samples++ >> 1;
                         }
                         } break;
                 }
@@ -479,11 +474,11 @@ uint FreeSurround::putSamples(char* samples, uint numSamples, uint numChannels,
                     for (i=0;(i<numSamples) && (ic < bs);i++,ic++)
                     {
                         int16bufs->l[ic] = *samples++ << 7;
-                        int16bufs->c[ic] = *samples++ << 7;
                         int16bufs->r[ic] = *samples++ << 7;
+                        int16bufs->c[ic] = *samples++ << 7;
+                        int16bufs->lfe[ic] = *samples++ << 7;
                         int16bufs->ls[ic] = *samples++ << 7;
                         int16bufs->rs[ic] = *samples++ << 7;
-                        int16bufs->lfe[ic] = *samples++ << 7;
                     }
                     break;
             }
@@ -541,11 +536,11 @@ uint FreeSurround::putSamples(char* samples, uint numSamples, uint numChannels,
                         for (i=0;i<numSamples;i++)
                         {
                             *l++ = *samples++ << 7;
-                            *c++ = *samples++ << 7;
                             *r++ = *samples++ << 7;
+                            *c++ = *samples++ << 7;
+                            *lfe++ = *samples++ << 7;
                             *ls++ = *samples++ << 7;
                             *rs++ = *samples++ << 7;
-                            *lfe++ = *samples++ << 7;
                         }
                         } break;
                 }
@@ -588,10 +583,10 @@ uint FreeSurround::receiveSamples(
             {
                 *output++ = int16bufs->l[outindex];
                 *output++ = int16bufs->r[outindex];
-                *output++ = int16bufs->ls[outindex];
-                *output++ = int16bufs->rs[outindex];
                 *output++ = int16bufs->c[outindex];
                 *output++ = int16bufs->lfe[outindex];
+                *output++ = int16bufs->ls[outindex];
+                *output++ = int16bufs->rs[outindex];
                 oc--;
                 outindex++;
             }
@@ -611,10 +606,10 @@ uint FreeSurround::receiveSamples(
                 {
                     *output++ = lrintf(*l++ INV_MASTER_GAIN);
                     *output++ = lrintf(*r++ INV_MASTER_GAIN);
-                    *output++ = lrintf(*ls++ INV_MASTER_GAIN);
-                    *output++ = lrintf(*rs++ INV_MASTER_GAIN);
                     *output++ = lrintf(*c++ INV_MASTER_GAIN);
                     *output++ = lrintf(*lfe++ INV_MASTER_GAIN);
+                    *output++ = lrintf(*ls++ INV_MASTER_GAIN);
+                    *output++ = lrintf(*rs++ INV_MASTER_GAIN);
                 }
                 oc -= maxSamples;
                 outindex += maxSamples;
@@ -631,10 +626,10 @@ uint FreeSurround::receiveSamples(
                 {
                     *output++ = *l++;
                     *output++ = *r++;
-                    *output++ = *ls++;
-                    *output++ = *rs++;
                     *output++ = *c++;
                     *output++ = *lfe++;
+                    *output++ = *ls++;
+                    *output++ = *rs++;
                 }
                 oc -= maxSamples;
                 outindex += maxSamples;
@@ -655,16 +650,6 @@ void FreeSurround::process_block()
     {
         if (decoder) 
         {
-            // actually these params need only be set when they change... but it doesn't hurt
-#if 0
-            decoder->steering_mode(params.steering);
-            decoder->phase_mode(params.phasemode);
-            decoder->surround_coefficients(params.coeff_a, params.coeff_b);				
-            decoder->separation(params.front_sep/100.0,params.rear_sep/100.0);
-#endif
-            // decode the bufs->block
-            //decoder->decode(input,output,params.center_width/100.0,params.dimension/100.0);
-            //decoder->decode(output,params.center_width/100.0,params.dimension/100.0);
             decoder->decode(params.center_width/100.0,params.dimension/100.0);
         }
     }
diff --git a/mythtv/libs/libmythtv/NuppelVideoPlayer.cpp b/mythtv/libs/libmythtv/NuppelVideoPlayer.cpp
index 3ea53c0..391f26d 100644
--- a/mythtv/libs/libmythtv/NuppelVideoPlayer.cpp
+++ b/mythtv/libs/libmythtv/NuppelVideoPlayer.cpp
@@ -212,9 +212,9 @@ NuppelVideoPlayer::NuppelVideoPlayer(bool muted)
       audioOutput(NULL),
       audio_main_device(QString::null),
       audio_passthru_device(QString::null),
-      audio_channels(2),            audio_bits(-1),
-      audio_samplerate(44100),      audio_stretchfactor(1.0f),
-      audio_codec(NULL),            audio_lock(QMutex::Recursive),
+      audio_channels(2),            audio_codec(0),
+      audio_bits(-1),               audio_samplerate(44100),
+      audio_stretchfactor(1.0f),    audio_lock(QMutex::Recursive),
       audio_muted_on_creation(muted),
       // Picture-in-Picture stuff
       pip_active(false),            pip_visible(true),
@@ -911,7 +911,7 @@ QString NuppelVideoPlayer::ReinitAudio(void)
         audioOutput = AudioOutput::OpenAudio(audio_main_device,
                                              audio_passthru_device,
                                              audio_bits, audio_channels,
-                                             audio_samplerate,
+                                             audio_codec, audio_samplerate,
                                              AUDIOOUTPUT_VIDEO,
                                              setVolume, audio_passthru);
         if (!audioOutput)
@@ -944,10 +944,11 @@ QString NuppelVideoPlayer::ReinitAudio(void)
 
     if (audioOutput)
     {
-        const AudioSettings settings(
-            audio_bits, audio_channels, audio_samplerate,
-            audio_passthru, audio_codec);
+        const AudioSettings settings(audio_bits, audio_channels, audio_codec,
+                                     audio_samplerate, audio_passthru);
         audioOutput->Reconfigure(settings);
+        if (audio_passthru)
+            audio_channels = 2;
         errMsg = audioOutput->GetError();
         if (!errMsg.isEmpty())
             audioOutput->SetStretchFactor(audio_stretchfactor);
@@ -3910,20 +3911,16 @@ bool NuppelVideoPlayer::StartPlaying(bool openfile)
     return !IsErrored();
 }
 
-void NuppelVideoPlayer::SetAudioParams(int bps, int channels,
+void NuppelVideoPlayer::SetAudioParams(int bps, int channels, int codec,
                                        int samplerate, bool passthru)
 {
     audio_bits = bps;
     audio_channels = channels;
+    audio_codec = codec;
     audio_samplerate = samplerate;
     audio_passthru = passthru;
 }
 
-void NuppelVideoPlayer::SetAudioCodec(void *ac)
-{
-    audio_codec = ac;
-}
-
 void NuppelVideoPlayer::SetEffDsp(int dsprate)
 {
     if (audioOutput)
@@ -5347,6 +5344,13 @@ void NuppelVideoPlayer::ToggleAdjustFill(AdjustFillMode adjustfillMode)
     }
 }
 
+bool NuppelVideoPlayer::ToggleUpmix()
+{
+    if (audioOutput)
+        return audioOutput->ToggleUpmix();
+    return false;
+}
+
 void NuppelVideoPlayer::Zoom(ZoomDirection direction)
 {
     if (videoOutput)
diff --git a/mythtv/libs/libmythtv/NuppelVideoPlayer.h b/mythtv/libs/libmythtv/NuppelVideoPlayer.h
index f930f02..d32c82e 100644
--- a/mythtv/libs/libmythtv/NuppelVideoPlayer.h
+++ b/mythtv/libs/libmythtv/NuppelVideoPlayer.h
@@ -125,7 +125,7 @@ class MPUBLIC NuppelVideoPlayer : public CC608Reader, public CC708Reader
     void SetAudioStretchFactor(float factor)  { audio_stretchfactor = factor; }
     void SetAudioOutput(AudioOutput *ao)      { audioOutput = ao; }
     void SetAudioInfo(const QString &main, const QString &passthru, uint rate);
-    void SetAudioParams(int bits, int channels, int samplerate, bool passthru);
+    void SetAudioParams(int bits, int channels, int codec, int samplerate, bool passthru);
     void SetEffDsp(int dsprate);
     uint AdjustVolume(int change);
     bool SetMuted(bool mute);
@@ -179,6 +179,7 @@ class MPUBLIC NuppelVideoPlayer : public CC608Reader, public CC708Reader
     // Toggle Sets
     void ToggleAspectOverride(AspectOverrideMode aspectMode = kAspect_Toggle);
     void ToggleAdjustFill(AdjustFillMode adjustfillMode = kAdjustFill_Toggle);
+    bool ToggleUpmix(void);
 
     // Gets
     QSize   GetVideoBufferSize(void) const    { return video_dim; }
@@ -714,10 +715,10 @@ class MPUBLIC NuppelVideoPlayer : public CC608Reader, public CC708Reader
     QString  audio_main_device;
     QString  audio_passthru_device;
     int      audio_channels;
+    int      audio_codec;
     int      audio_bits;
     int      audio_samplerate;
     float    audio_stretchfactor;
-    void    *audio_codec;
     bool     audio_passthru;
     QMutex   audio_lock;
 
diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index 06350da..e4ccb1d 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -461,8 +461,9 @@ AvFormatDecoder::AvFormatDecoder(NuppelVideoPlayer *parent,
       // Audio
       audioSamples(NULL),
       allow_ac3_passthru(false),    allow_dts_passthru(false),
+      internal_vol(false),
       disable_passthru(false),      max_channels(2),
-      dummy_frame(NULL),
+      last_ac3_channels(0),	    dummy_frame(NULL),
       // DVD
       lastdvdtitle(-1),
       decodeStillFrame(false),
@@ -480,9 +481,10 @@ AvFormatDecoder::AvFormatDecoder(NuppelVideoPlayer *parent,
     av_log_set_level((debug) ? AV_LOG_DEBUG : AV_LOG_ERROR);
     av_log_set_callback(myth_av_log);
 
-    allow_ac3_passthru = gContext->GetNumSetting("AC3PassThru", false);
-    allow_dts_passthru = gContext->GetNumSetting("DTSPassThru", false);
     max_channels = (uint) gContext->GetNumSetting("MaxChannels", 2);
+    allow_ac3_passthru = (max_channels > 2) ? gContext->GetNumSetting("AC3PassThru", false) : false;
+    allow_dts_passthru = (max_channels > 2) ? gContext->GetNumSetting("DTSPassThru", false) : false;
+    internal_vol = gContext->GetNumSetting("MythControlsVolume", 0);
 
     audioIn.sample_size = -32; // force SetupAudioStream to run once
     itv = GetNVP()->GetInteractiveTV();
@@ -2024,7 +2026,7 @@ int AvFormatDecoder::ScanStreams(bool novideo)
     // waiting on audio.
     if (GetNVP()->HasAudioIn() && tracks[kTrackTypeAudio].empty())
     {
-        GetNVP()->SetAudioParams(-1, -1, -1, false /* AC3/DTS pass-through */);
+        GetNVP()->SetAudioParams(-1, -1, CODEC_ID_NONE, -1, false /* AC3/DTS pass-through */);
         GetNVP()->ReinitAudio();
         if (ringBuffer && ringBuffer->isDVD())
             audioIn = AudioInfo();
@@ -3059,15 +3061,9 @@ int AvFormatDecoder::AutoSelectAudioTrack(void)
     {
         int idx = atracks[i].av_stream_index;
         AVCodecContext *codec_ctx = ic->streams[idx]->codec;
-        bool do_ac3_passthru = (allow_ac3_passthru && !transcoding &&
-                                !disable_passthru &&
-                                (codec_ctx->codec_id == CODEC_ID_AC3));
-        bool do_dts_passthru = (allow_dts_passthru && !transcoding &&
-                                !disable_passthru &&
-                                (codec_ctx->codec_id == CODEC_ID_DTS));
         AudioInfo item(codec_ctx->codec_id,
                        codec_ctx->sample_rate, codec_ctx->channels,
-                       do_ac3_passthru || do_dts_passthru);
+                       DoPassThrough(codec_ctx));
         VERBOSE(VB_AUDIO, LOC + " * " + item.toString());
     }
 #endif
@@ -3201,6 +3197,7 @@ static void extract_mono_channel(uint channel, AudioInfo *audioInfo,
 bool AvFormatDecoder::GetFrame(int onlyvideo)
 {
     AVPacket *pkt = NULL;
+    AC3HeaderInfo hdr;
     int len;
     unsigned char *ptr;
     int data_size = 0;
@@ -3631,14 +3628,6 @@ bool AvFormatDecoder::GetFrame(int onlyvideo)
                         reselectAudioTrack = true;
                     }
 
-                    bool do_ac3_passthru =
-                        (allow_ac3_passthru && !transcoding &&
-                         (curstream->codec->codec_id == CODEC_ID_AC3));
-                    bool do_dts_passthru =
-                        (allow_dts_passthru && !transcoding &&
-                         (curstream->codec->codec_id == CODEC_ID_DTS));
-                    bool using_passthru = do_ac3_passthru || do_dts_passthru;
-
                     // detect channels on streams that need
                     // to be decoded before we can know this
                     bool already_decoded = false;
@@ -3649,7 +3638,7 @@ bool AvFormatDecoder::GetFrame(int onlyvideo)
                                 QString("Setting channels to %1")
                                 .arg(audioOut.channels));
 
-                        if (using_passthru)
+                        if (DoPassThrough(curstream->codec))
                         {
                             // for passthru let it select the max number
                             // of channels
@@ -3671,6 +3660,20 @@ bool AvFormatDecoder::GetFrame(int onlyvideo)
                         reselectAudioTrack |= curstream->codec->channels;
                     }
 
+                    if (curstream->codec->codec_id == CODEC_ID_AC3)
+                    {
+                        GetBitContext gbc;
+                        init_get_bits(&gbc, ptr, len * 8);
+                        if (!ff_ac3_parse_header(&gbc, &hdr)) 
+                        {
+                            if (hdr.channels != last_ac3_channels) 
+                            {
+                                last_ac3_channels = curstream->codec->channels = hdr.channels;
+                                SetupAudioStream();
+                            }
+                        }
+                    }
+
                     if (reselectAudioTrack)
                     {
                         QMutexLocker locker(&avcodeclock);
@@ -4196,6 +4199,25 @@ void AvFormatDecoder::SetDisablePassThrough(bool disable)
     }
 }
 
+bool AvFormatDecoder::DoPassThrough(const AVCodecContext *ctx)
+{
+    bool passthru = false; 
+
+    if (ctx->codec_id == CODEC_ID_AC3)
+        passthru = allow_ac3_passthru && 
+                   ctx->channels >= (int)max_channels &&
+                   !internal_vol;
+    else if (ctx->codec_id == CODEC_ID_DTS)
+        passthru = allow_dts_passthru && !internal_vol;
+
+    passthru &= !transcoding && !disable_passthru;
+    // Don't know any cards that support spdif clocked at < 44100
+    // Some US cable transmissions have 2ch 32k AC-3 streams
+    passthru &= ctx->sample_rate >= 44100;
+
+    return passthru;
+}
+
 /** \fn AvFormatDecoder::SetupAudioStream(void)
  *  \brief Reinitializes audio if it needs to be reinitialized.
  *
@@ -4209,7 +4231,6 @@ bool AvFormatDecoder::SetupAudioStream(void)
     AVStream *curstream = NULL;
     AVCodecContext *codec_ctx = NULL;
     AudioInfo old_in  = audioIn;
-    AudioInfo old_out = audioOut;
     bool using_passthru = false;
 
     if ((currentTrack[kTrackTypeAudio] >= 0) &&
@@ -4223,14 +4244,9 @@ bool AvFormatDecoder::SetupAudioStream(void)
         codec_ctx = curstream->codec;
         if (codec_ctx)
         {
-            bool do_ac3_passthru = (allow_ac3_passthru && !transcoding &&
-                                    (codec_ctx->codec_id == CODEC_ID_AC3));
-            bool do_dts_passthru = (allow_dts_passthru && !transcoding &&
-                                    (codec_ctx->codec_id == CODEC_ID_DTS));
-            using_passthru = do_ac3_passthru || do_dts_passthru;
-            info = AudioInfo(codec_ctx->codec_id,
-                             codec_ctx->sample_rate, codec_ctx->channels,
-                             using_passthru && !disable_passthru);
+            using_passthru = DoPassThrough(codec_ctx);
+            info = AudioInfo(codec_ctx->codec_id, codec_ctx->sample_rate, 
+                            codec_ctx->channels, using_passthru);
         }
     }
 
@@ -4247,41 +4263,25 @@ bool AvFormatDecoder::SetupAudioStream(void)
             QString("audio track #%1").arg(currentTrack[kTrackTypeAudio]+1));
 
     audioOut = audioIn = info;
-    AudioInfo tmpAudioOut = audioOut;
 
-    // A passthru stream looks like a 48KHz 2ch (@ 16bit) to the sound card
-    if (using_passthru && !disable_passthru)
+    if (!using_passthru && audioOut.channels > (int)max_channels)
     {
-        tmpAudioOut.channels    = 2;
-        tmpAudioOut.sample_rate = 48000;
-        tmpAudioOut.sample_size = 4;
-    }
-
-    if (audioOut.channels > (int) max_channels)
-    {
-        audioOut.channels    = (int) max_channels;
+        audioOut.channels = (int)max_channels;
         audioOut.sample_size = audioOut.channels * 2;
-        codec_ctx->channels  = audioOut.channels;
+        codec_ctx->channels = audioOut.channels;
     }
 
-    if (!using_passthru)
-        tmpAudioOut = audioOut;
-
     VERBOSE(VB_AUDIO, LOC + "Audio format changed " +
-            QString("%1%2\n\t\t\tfrom %3 ; %4\n\t\t\tto   %5 ; %6")
-            .arg((using_passthru) ? "digital passthrough " : "")
-            .arg((using_passthru) ? tmpAudioOut.toString() : QString(""))
-            .arg(old_in.toString()).arg(old_out.toString())
-            .arg(audioIn.toString()).arg(audioOut.toString()));
+            QString("\n\t\t\tfrom %1 to %2")
+            .arg(old_in.toString()).arg(audioOut.toString()));
 
-    if (tmpAudioOut.sample_rate > 0)
-        GetNVP()->SetEffDsp(tmpAudioOut.sample_rate * 100);
+    if (audioOut.sample_rate > 0)
+        GetNVP()->SetEffDsp(audioOut.sample_rate * 100);
 
-    GetNVP()->SetAudioParams(tmpAudioOut.bps(), tmpAudioOut.channels,
-                             tmpAudioOut.sample_rate, audioIn.do_passthru);
+    GetNVP()->SetAudioParams(audioOut.bps(), audioOut.channels,
+                             audioOut.codec_id, audioOut.sample_rate,
+                             audioOut.do_passthru);
 
-    // allow the audio stuff to reencode
-    GetNVP()->SetAudioCodec((using_passthru) ? codec_ctx : NULL);
     GetNVP()->ReinitAudio();
 
     return true;
diff --git a/mythtv/libs/libmythtv/avformatdecoder.h b/mythtv/libs/libmythtv/avformatdecoder.h
index 9c05180..917fe43 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.h
+++ b/mythtv/libs/libmythtv/avformatdecoder.h
@@ -188,6 +188,7 @@ class AvFormatDecoder : public DecoderBase
 
     void SeekReset(long long, uint skipFrames, bool doFlush, bool discardFrames);
 
+    bool DoPassThrough(const AVCodecContext *ctx);
     bool SetupAudioStream(void);
     void SetupAudioStreamSubIndexes(int streamIndex);
     void RemoveAudioStreams();
@@ -258,8 +259,10 @@ class AvFormatDecoder : public DecoderBase
     short int        *audioSamples;
     bool              allow_ac3_passthru;
     bool              allow_dts_passthru;
+    bool              internal_vol;
     bool              disable_passthru;
     uint              max_channels;
+    uint              last_ac3_channels;
 
     VideoFrame       *dummy_frame;
 
diff --git a/mythtv/libs/libmythtv/nuppeldecoder.cpp b/mythtv/libs/libmythtv/nuppeldecoder.cpp
index bc9c4d3..8cf4a5c 100644
--- a/mythtv/libs/libmythtv/nuppeldecoder.cpp
+++ b/mythtv/libs/libmythtv/nuppeldecoder.cpp
@@ -495,6 +495,7 @@ int NuppelDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
 #endif
         GetNVP()->SetAudioParams(extradata.audio_bits_per_sample,
                                  extradata.audio_channels, 
+                                 CODEC_ID_NONE,
                                  extradata.audio_sample_rate,
                                  false /* AC3/DTS pass through */);
         GetNVP()->ReinitAudio();
diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index d42524a..fefdf72 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -496,6 +496,7 @@ void TV::InitKeys(void)
     REG_KEY("TV Playback", "VOLUMEDOWN", "Volume down", "[,{,F10,Volume Down");
     REG_KEY("TV Playback", "VOLUMEUP",   "Volume up",   "],},F11,Volume Up");
     REG_KEY("TV Playback", "MUTE",       "Mute",        "|,\\,F9,Volume Mute");
+    REG_KEY("TV Playback", "TOGGLEUPMIX", "Toggle audio upmixer", "Ctrl+U");
     REG_KEY("TV Playback", "TOGGLEPIPMODE", "Toggle Picture-in-Picture view",
             "V");
     REG_KEY("TV Playback", "TOGGLEPBPMODE", "Toggle Picture-by-Picture view",
@@ -633,7 +634,7 @@ void TV::InitKeys(void)
   Teletext     F2,F3,F4,F5,F6,F7,F8
   ITV          F2,F3,F4,F5,F6,F7,F12
 
-  Playback: Ctrl-B,Ctrl-G,Ctrl-Y
+  Playback: Ctrl-B,Ctrl-G,Ctrl-Y,Ctrl-U
 */
 }
 
@@ -4349,6 +4350,8 @@ bool TV::ToggleHandleAction(PlayerContext *ctx,
         DoTogglePictureAttribute(ctx, kAdjustingPicture_Playback);
     else if (has_action("TOGGLESTRETCH", actions))
         ToggleTimeStretch(ctx);
+    else if (has_action("TOGGLEUPMIX", actions))
+        ToggleUpmix(ctx);
     else if (has_action("TOGGLESLEEP", actions))
         ToggleSleepTimer(ctx);
     else if (has_action("TOGGLERECORD", actions) && islivetv)
@@ -7984,6 +7987,20 @@ void TV::ChangeTimeStretch(PlayerContext *ctx, int dir, bool allowEdit)
     SetSpeedChangeTimer(0, __LINE__);
 }
 
+void TV::ToggleUpmix(PlayerContext *ctx)
+{
+    if (!ctx->nvp || !ctx->nvp->HasAudioOut())
+        return;
+    QString text;
+    if (ctx->nvp->ToggleUpmix())
+        text = tr("Upmixer On");
+    else
+        text = tr("Upmixer Off");
+    
+    if (ctx->nvp->GetOSD() && !browsemode)
+        ctx->nvp->GetOSD()->SetSettingsText(text, 5);
+}
+    
 // dir in 10ms jumps
 void TV::ChangeAudioSync(PlayerContext *ctx, int dir, bool allowEdit)
 {
@@ -9613,6 +9630,8 @@ void TV::TreeMenuSelected(OSDListTreeItemSelectedEvent *e)
         SetManualZoom(actx, true, tr("Zoom Mode ON"));
     else if (action == "TOGGLESTRETCH")
         ToggleTimeStretch(actx);
+    else if (action == "TOGGLEUPMIX")
+        ToggleUpmix(actx);
     else if (action.left(13) == "ADJUSTSTRETCH")
     {
         bool floatRead;
@@ -9978,6 +9997,8 @@ void TV::FillOSDTreeMenu(
 
     if (category == "AUDIOSYNC")
         new OSDGenericTree(treeMenu, tr("Adjust Audio Sync"), "TOGGLEAUDIOSYNC");
+    else if (category == "TOGGLEUPMIX")
+        new OSDGenericTree(treeMenu, tr("Toggle Audio Upmixer"), "TOGGLEUPMIX");
     else if (category == "TIMESTRETCH")
         FillMenuTimeStretch(ctx, treeMenu);
     else if (category == "VIDEOSCAN")
diff --git a/mythtv/libs/libmythtv/tv_play.h b/mythtv/libs/libmythtv/tv_play.h
index d528b68..da2c1ab 100644
--- a/mythtv/libs/libmythtv/tv_play.h
+++ b/mythtv/libs/libmythtv/tv_play.h
@@ -429,6 +429,7 @@ class MPUBLIC TV : public QThread
     bool TimeStretchHandleAction(PlayerContext*,
                                  const QStringList &actions);
 
+    void ToggleUpmix(PlayerContext*);
     void ChangeAudioSync(PlayerContext*, int dir, bool allowEdit = true);
     bool AudioSyncHandleAction(PlayerContext*, const QStringList &actions);
 
diff --git a/mythtv/libs/libmythtv/tvosdmenuentry.cpp b/mythtv/libs/libmythtv/tvosdmenuentry.cpp
index 77db6ed..56eb24f 100644
--- a/mythtv/libs/libmythtv/tvosdmenuentry.cpp
+++ b/mythtv/libs/libmythtv/tvosdmenuentry.cpp
@@ -232,6 +232,8 @@ void TVOSDMenuEntryList::InitDefaultEntries(void)
     curMenuEntries.append(new TVOSDMenuEntry(
         "AUDIOSYNC",          1,  1,  1,  1, "Audio Sync"));
     curMenuEntries.append(new TVOSDMenuEntry(
+        "TOGGLEUPMIX",        1,  1,  1,  1, "Toggle Upmixer"));
+    curMenuEntries.append(new TVOSDMenuEntry(
         "TIMESTRETCH",        1,  1,  1,  1, "Time Stretch"));
     curMenuEntries.append(new TVOSDMenuEntry(
         "VIDEOSCAN",          1,  1,  1,  1, "Video Scan"));
diff --git a/mythtv/programs/mythfrontend/globalsettings.cpp b/mythtv/programs/mythfrontend/globalsettings.cpp
index b071fd7..ff13fa7 100644
--- a/mythtv/programs/mythfrontend/globalsettings.cpp
+++ b/mythtv/programs/mythfrontend/globalsettings.cpp
@@ -91,13 +91,23 @@ static HostComboBox *AudioOutputDevice()
 static HostComboBox *MaxAudioChannels()
 {
     HostComboBox *gc = new HostComboBox("MaxChannels",false);
-    gc->setLabel(QObject::tr("Max Audio Channels"));
+    gc->setLabel(QObject::tr("Speakers configuration"));
     gc->addSelection(QObject::tr("Stereo"), "2", true); // default
     gc->addSelection(QObject::tr("5.1"), "6");
     gc->setHelpText(
             QObject::tr(
-                "Set the maximum number of audio channels to be decoded. "
-                "This is for multi-channel/surround audio playback."));
+                "Set your audio configuration: Stereo or Surround."));
+    return gc;
+}
+
+static HostCheckBox *AudioUpmix()
+{
+    HostCheckBox *gc = new HostCheckBox("AudioDefaultUpmix");
+    gc->setLabel(QObject::tr("Upconvert stereo to 5.1 surround"));
+    gc->setValue(true);
+    gc->setHelpText(QObject::tr("MythTV can upconvert stereo to 5.1 audio. "
+                                "Set this option to enable it by default. "
+                                "You can enable or disable the upconversion during playback at anytime."));
     return gc;
 }
 
@@ -105,16 +115,13 @@ static HostComboBox *AudioUpmixType()
 {
     HostComboBox *gc = new HostComboBox("AudioUpmixType",false);
     gc->setLabel(QObject::tr("Upmix"));
-    gc->addSelection(QObject::tr("Passive"), "0", true); // default
-    gc->addSelection(QObject::tr("Active Simple"), "1");
-    gc->addSelection(QObject::tr("Active Linear"), "2");
+    gc->addSelection(QObject::tr("Fastest"), "0", true); // default
+    gc->addSelection(QObject::tr("Good"), "1");
+    gc->addSelection(QObject::tr("Best"), "2");
     gc->setHelpText(
             QObject::tr(
-                "Set the audio upmix type for 2ch to 6ch conversion. "
-                "This is for multi-channel/surround audio playback. "
-                "'Passive' is the least demanding on the CPU. "
-                "'Active Simple' is more demanding and 'Active Linear' "
-                "is the most demanding (but highest quality)."));
+                "Set the audio surround upconversion quality. "
+                "'Fastest' is the least demanding on the CPU at the expense of quality."));
     return gc;
 }
 
@@ -122,7 +129,7 @@ static HostComboBox *PassThroughOutputDevice()
 {
     HostComboBox *gc = new HostComboBox("PassThruOutputDevice", true);
 
-    gc->setLabel(QObject::tr("Passthrough output device"));
+    gc->setLabel(QObject::tr("Digital output device"));
     gc->addSelection(QObject::tr("Default"), "Default");
 #ifndef USING_MINGW
     gc->addSelection("ALSA:iec958:{ AES0 0x02 }", "ALSA:iec958:{ AES0 0x02 }");
@@ -130,8 +137,7 @@ static HostComboBox *PassThroughOutputDevice()
     gc->addSelection("ALSA:plughw:0,3", "ALSA:plughw:0,3");
 #endif
 
-    gc->setHelpText(QObject::tr("Audio output device to use for AC3 and "
-                    "DTS passthrough. Default is the same as Audio output "
+    gc->setHelpText(QObject::tr("Audio output device to use for digital audio. Default is the same as Audio output "
                     "device. This value is currently only used with ALSA "
                     "sound output."));
     return gc;
@@ -143,8 +149,9 @@ static HostCheckBox *MythControlsVolume()
     gc->setLabel(QObject::tr("Use internal volume controls"));
     gc->setValue(true);
     gc->setHelpText(QObject::tr("MythTV can control the PCM and master "
-                    "mixer volume.  If you prefer to use an external mixer "
-                    "program, then disable this option."));
+                    "mixer volume.  If you prefer to control the volume externally "
+                    "(like your amplifier) or use an external mixer "
+                    "program, disable this option."));
     return gc;
 }
 
@@ -170,6 +177,11 @@ static HostComboBox *MixerDevice()
     gc->addSelection("DirectX:", "DirectX:");
     gc->addSelection("Windows:", "Windows:");
 #endif
+#if !defined(USING_MINGW)
+    gc->addSelection("software", "software");
+    gc->setHelpText(QObject::tr("Setting the mixer device to \"software\" lets MythTV control "
+                                "the volume of all audio at the expense of a slight quality loss."));
+#endif
 
     return gc;
 }
@@ -230,24 +242,20 @@ static HostCheckBox *IndividualMuteControl()
 static HostCheckBox *AC3PassThrough()
 {
     HostCheckBox *gc = new HostCheckBox("AC3PassThru");
-    gc->setLabel(QObject::tr("Enable AC3 to SPDIF passthrough"));
+    gc->setLabel(QObject::tr("Dolby Digital"));
     gc->setValue(false);
-    gc->setHelpText(QObject::tr("Enable sending AC3 audio directly to your "
-                    "sound card's SPDIF output, on sources which contain "
-                    "AC3 soundtracks (usually digital TV).  Requires that "
-                    "the audio output device be set to something suitable."));
+    gc->setHelpText(QObject::tr("Enable if your amplifier or sound decoder supports AC3/Dolby Digital. "
+                                "You must use a digital connection. Uncheck if using an analog connection."));
     return gc;
 }
 
 static HostCheckBox *DTSPassThrough()
 {
     HostCheckBox *gc = new HostCheckBox("DTSPassThru");
-    gc->setLabel(QObject::tr("Enable DTS to SPDIF passthrough"));
+    gc->setLabel(QObject::tr("DTS"));
     gc->setValue(false);
-    gc->setHelpText(QObject::tr("Enable sending DTS audio directly to your "
-                    "sound card's SPDIF output, on sources which contain "
-                    "DTS soundtracks (usually DVDs).  Requires that the "
-                    "audio output device be set to something suitable."));
+    gc->setHelpText(QObject::tr("Enable if your amplifier or sound decoder supports DTS. "
+                                "You must use a digital connection. Uncheck if using an analog connection"));
     return gc;
 }
 
@@ -1985,18 +1993,6 @@ static HostCheckBox *BrowseAllTuners()
     return gc;
 }
 
-static HostCheckBox *AggressiveBuffer()
-{
-    HostCheckBox *gc = new HostCheckBox("AggressiveSoundcardBuffer");
-    gc->setLabel(QObject::tr("Aggressive Sound card Buffering"));
-    gc->setValue(false);
-    gc->setHelpText(QObject::tr("If enabled, MythTV will pretend to have "
-                   "a smaller sound card buffer than is really present.  This "
-                   "may speed up seeking, but can also cause playback "
-                   "problems."));
-    return gc;
-}
-
 static HostCheckBox *ClearSavedPosition()
 {
     HostCheckBox *gc = new HostCheckBox("ClearSavedPosition");
@@ -3505,25 +3501,43 @@ static HostSpinBox *EPGRecThreshold()
     return gs;
 }
 
-class AudioSystemSettingsGroup : public VerticalConfigurationGroup
+class AudioSystemSettingsGroup : public TriggeredConfigurationGroup
 {
   public:
     AudioSystemSettingsGroup() :
-        VerticalConfigurationGroup(false, true, false, false)
+        TriggeredConfigurationGroup(false, true, false, false)
     {
         setLabel(QObject::tr("Audio System"));
         setUseLabel(false);
 
         addChild(AudioOutputDevice());
-        addChild(PassThroughOutputDevice());
 
-        addChild(MaxAudioChannels());
-        addChild(AudioUpmixType());
+        Setting *numchannels = MaxAudioChannels();
+        addChild(numchannels);
+
+        ConfigurationGroup *dummy =
+        new VerticalConfigurationGroup(false, true, false, false);
+
+        ConfigurationGroup *settings =
+        new VerticalConfigurationGroup(false, true, false, false);
+
+        settings->addChild(AudioUpmix());
+        settings->addChild(AudioUpmixType());
+        settings->addChild(PassThroughOutputDevice());
+
+        ConfigurationGroup *settings2 =
+        new HorizontalConfigurationGroup();
+        settings2->setLabel(QObject::tr("Audio Processing Capabilities"));
+        settings2->addChild(AC3PassThrough());
+        settings2->addChild(DTSPassThrough());
+
+        settings->addChild(settings2);
 
-        // General boolean settings
-        addChild(AC3PassThrough());
-        addChild(DTSPassThrough());
-        addChild(AggressiveBuffer());
+        // Show surround/upmixer config only if 5.1 Audio is selected
+        setTrigger(numchannels);
+        addTarget("2", dummy);
+        addTarget("6", settings);
+        
     }
 };
 
diff --git a/mythtv/programs/mythtranscode/transcode.cpp b/mythtv/programs/mythtranscode/transcode.cpp
index ff8eb54..fe6d1fa 100644
--- a/mythtv/programs/mythtranscode/transcode.cpp
+++ b/mythtv/programs/mythtranscode/transcode.cpp
@@ -49,7 +49,7 @@ class AudioReencodeBuffer : public AudioOutput
     AudioReencodeBuffer(int audio_bits, int audio_channels)
     {
         Reset();
-        const AudioSettings settings(audio_bits, audio_channels, 0, false);
+        const AudioSettings settings(audio_bits, audio_channels, 0, 0, false);
         Reconfigure(settings);
         bufsize = 512000;
         audiobuffer = new unsigned char[bufsize];
@@ -222,6 +222,22 @@ class AudioReencodeBuffer : public AudioOutput
         // Do nothing
         return kMuteOff;
     }
+    virtual bool ToggleUpmix(void) 
+    {
+        // Do nothing
+        return false;
+    }
+
+    virtual void SetSWVolume(int new_volume, bool save)
+    {
+        // Do nothing
+        return;
+    }
+    virtual int GetSWVolume(void)
+    {
+        // Do nothing
+        return 100;
+    }
 
     //  These are pure virtual in AudioOutput, but we don't need them here
     virtual void bufferOutputData(bool){ return; }
